---
title: "01_ventilation_variation_script"
author: Nick Ingraham
date: today
execute: 
  echo: false
format: 
  html:
    embed-resources: true
    number-sections: true
    toc: true
    html-q-tags: true
    code-fold: true
editor: source
editor_options: 
  chunk_output_type: console
---

## CLIF Setup
```{r}
# Install renv if not already installed:
# if (!requireNamespace("renv", quietly = TRUE)) {
#   install.packages("renv")
# }

# renv::activate()
# renv::restore()
```


```{r}
# # Initialize renv for the project:
# renv::init(bare = TRUE, settings = list(use.cache = FALSE))
# 
# # Install required packages:
# renv::install("BiocManager")
# BiocManager::install("IRanges")
# 
# # renv::update()
# renv::install(c("tidyverse", "ggthemes", "systemfonts",  "styler", "readxl", "writexl", "DBI", "dbplyr", "knitr", "pandoc", "janitor", "data.table", "duckdb" ,"powerjoin", "collapse", "tidyfast", "datapasta", "fst", "dtplyr", "bit64", "zoo", "fuzzyjoin", "arrow", "hrbrthemes", "here", "table1", "rvest", "tidymodels", "pscl", "survminer"))
# 
# #, dependencies = TRUE
#  # "KMsurv"
# # Save the project's package state:
# renv::snapshot()


```

### Libraries

```{r}
#| label: installing packages
#| timeit: true


packages <- c("tidyverse", "ggthemes", "systemfonts",  "styler", "readxl", "writexl", "DBI", "dbplyr", "knitr", "janitor", "pandoc", "data.table", "duckdb" ,"powerjoin", "collapse", "tidyfast", "datapasta", "fst", "dtplyr", "bit64", "zoo", "fuzzyjoin", "arrow", "hrbrthemes", "here", "table1", "rvest", "tidymodels", "pscl", "survival", "survminer")
# 
# install_if_missing <- function(package) {
#   if (!require(package, character.only = TRUE)) {
#     renv::install(package, dependencies = TRUE)
#     library(package, character.only = TRUE)
#   }
# }

load_function <- function(package) {
    library(package, character.only = TRUE)
}

sapply(packages, load_function)

```


### Utils

```{r}
# Load the configuration utility
source("utils/config.R")

# Access configuration parameters
site_name <- config$site_name
tables_path <- config$tables_path
file_type <- config$file_type


# Print the configuration parameters
print(paste("Site Name:", site_name))
print(paste("Tables Path:", tables_path))
print(paste("File Type:", file_type))



# List of all table names from the CLIF 2.0 ERD
tables <- c(
  "patient",
  "hospitalization",
  "vitals",
  "labs",
  "medication_admin_continuous",
  "adt",
  "patient_assessments",
  "respiratory_support",
  "position",
  "dialysis",
  "intake_output",
  "ecmo_mcs",
  "procedures",
  "admission_diagnosis",
  "provider",
  "sensitivity",
  "medication_orders",
  "medication_admin_intermittent",
  "therapy_details",
  "microbiology_culture",
  "sensitivity",
  "microbiology_nonculture"
  )

# Tables that should be set to TRUE for this project
true_tables <- c(
  "hospitalization",
  "vitals",
  "labs",
  "medication_admin_continuous",
  "adt",
  # "patient_assessments",
  "respiratory_support",
  "position",
  # "dialysis",
  # "intake_output",
  # "ecmo_mcs",
  "procedures",
  # "admission_diagnosis",
  # "provider",
  # "sensitivity",
  # "medication_orders",
  # "medication_admin_intermittent",
  # "therapy_details",
  # "microbiology_culture",
  # "sensitivity",
  # "microbiology_nonculture",
  "patient"
  )

# Create a named vector and set the boolean values
table_flags <- setNames(tables %in% true_tables, tables)


# List all CLIF files in the directory
clif_table_filenames <- list.files(path = tables_path, 
                                   pattern = paste0("^clif_.*\\.", file_type, "$"), 
                                   full.names = TRUE)

# Extract the base names of the files (without extension)
clif_table_basenames <- basename(clif_table_filenames) %>%
  str_remove(paste0("\\.", file_type, "$"))

# Create a lookup table for required files based on table_flags
required_files <- paste0("clif_", names(table_flags)[table_flags])

# Check if all required files are present
missing_tables <- setdiff(required_files, clif_table_basenames)
if (length(missing_tables) > 0) {
    stop(paste("Missing required tables:", 
               paste(missing_tables, collapse = ", ")))
}

# Filter only the filenames that are required
required_filenames <- clif_table_filenames[clif_table_basenames %in% required_files] 


```


### Functions

```{r}
#| label: Functions
#| timeit: true


# Quickly look at the data like we would in stata, default is 100
ni_peek <- function(x, n=100){
  view(head(x, n))
}

# check missing variables
ni_count_missing <- function(df, group_vars, x_var) {
  df |> 
    group_by(pick({{ group_vars }})) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
    )
}
# flights |>  count_missing(c(year, month, day), dep_time)

# look at the variables
ni_check_variables <- function(df, n=500) {
  check <- tibble(
    col_name = names(df), 
    col_type = map_chr(df, vctrs::vec_ptype_full),
    n_miss = map_int(df, \(x) sum(is.na(x)))
  )
  print(check, n=n)
}

ni_count_prop <- function(df, var, sort = TRUE) {
  df |>
    count({{ var }}, sort = sort) |>
    mutate(prop = n / sum(n)
    )
}

# Identify and create a table of duplicate rows based on hospitalization_id
ni_duplicate_finder <- function(df, group_vars = c(hospitalization_id), n=1){
df |> 
  dplyr::group_by(pick({{ group_vars }})) |> 
  filter(n() > {{ n }}) |> 
  ungroup()
}

ni_tic <- function() {
  .GlobalEnv$time_start_temp <- proc.time()
  .GlobalEnv$time_start_sys <- Sys.time()
  return(Sys.time())
}

ni_toc <- function() {
  time_end_sys <- Sys.time()
  .GlobalEnv$time_diff.time <- round(time_end_sys - time_start_sys,2)
  mylist <- list(time_diff.time, cat("Finished in",timetaken(time_start_temp),"\n"
             ))
return(print(mylist[[1]]))
}

fio2warning <- function() {
  warning("fio2 variable needed to be fixed, it was multiplied by 100!!!")
}

labwarning <- function() {
  warning("lab values are character and needed to be fixed, they were forced to numeric!!!")
}

vitalwarning <- function() {
  warning("vital values are character and needed to be fixed, they were forced to numeric!!!")
}



read_data <- function(file_path) {
  file_path_temp <- paste0(path_cliffed_files,"/", file_path, ".", file_type)
  print(file_path_temp)
  
  if (grepl("\\.csv$", file_path_temp)) {
    return(read.csv(file_path_temp) 
    )
    
  } else if (grepl("\\.parquet$", file_path_temp)) {
    return(arrow::open_dataset(file_path_temp)  |> 
             collect()
    )
    
  } else if (grepl("\\.fst$", file_path_temp)) {
    return(fst::read.fst(file_path_temp) 
    )
  } else {
    stop("Unsupported file format")
  }
}


```

# Import

### Cohort identification

```{r}
#~~~~~~~~~~
# ID cohort
#~~~~~~~~~~


## Date range
start_date <- "2020-01-01"
end_date <- "2021-12-31"


# Main Respiratory Support Table
#~~ using readr or fst or arrow (parquet) package depending on the file type. (THESE WERE SET DURING SET UP ^^ )
clif_respiratory_support_start <- read_data("clif_respiratory_support") |> select(hospitalization_id, device_category, tracheostomy) 
clif_hospitalization_start <- read_data("clif_hospitalization") |> select(hospitalization_id, admission_dttm, age_at_admission, patient_id)


# getting a keep_list of hospitalization_ids that have vent or trach during their encounter... we will use this right_join the dfs below
df_cohort_keep <- clif_respiratory_support_start |> 
  
# Just getting those ventilated or trach
  filter(str_to_lower(device_category) == "imv" | tracheostomy == 1) |> 
  
# getting age at admission
  left_join(clif_hospitalization_start) |> 
  
# Exclusion based on date
  left_join(clif_hospitalization_start) |>
  filter(
    lubridate::date(admission_dttm) >= start_date | hospitalization_id == 1767475 | hospitalization_id == 2044432,
    lubridate::date(admission_dttm) <= end_date,
# age exclusion
    age_at_admission >= 18,
# missing data exclusion
    !is.na(age_at_admission)
    ) |>  
  select(hospitalization_id, patient_id) |> 
  distinct()

# List all objects in the global environment
all_objects <- ls()

# Identify objects ending with "_start"
df_start_objects <- grep("_start$", all_objects, value = TRUE)

# Remove identified objects
rm(list = df_start_objects)
gc()

```

### Importing function

```{r}
#~~~~~~~~~~
# Importing function
#~~~~~~~~~~

# Function for importing files easily just with the file of the clif_table
import_df <- function(x) {
  # Construct the file path
  file_path <- paste0(path_cliffed_files,"/", x, ".", file_type)
  
  # Dynamically call the appropriate read function based on file_type
  
  if (file_type == "parquet") {
    
  read_function <- get(paste0("open_dataset")) 
  
  df <- read_function(file_path) |>
    
    # helps with glitch in open_dataset
    mutate(across(where(is.character), as.character)) |> 
    
    # right join early so files are smaller
    right_join(df_cohort_keep) |> 
    
    # unfactor things to ensure everything is lowercase
    mutate(across(where(is.factor), as.character)) |> 
    
    # get everything to lower
    mutate(across(where(is_character), str_to_lower)) |> 
    
    # only need if using open dataset
    collect()
  
  } else {
    
    read_function <- get(paste0("read_", file_type)) 
    
    df <- read_function(file_path) |>
      
      # right join early so files are smaller
      right_join(df_cohort_keep) |> 
      
      # unfactor things to ensure everything is lowercase
      mutate(across(where(is.factor), as.character)) |> 
      
      # get everything to lower
      mutate(across(where(is_character), str_to_lower)) 
      
  }
  
  
  # Find all datetime variables containing 'dttm'
  datetime_vars <- names(df)[grepl("dttm", names(df))]
  
  # Check and convert datetime variables
  for (var in datetime_vars) {
    if (!inherits(df[[var]], "POSIXct")) {
      
      # Attempt to parse datetime using a common format, adjust based on your actual format
      df[[var]] <- ymd_hms(df[[var]], quiet = TRUE)
      
      # Check if it just turned things into NA
      if (is.na(ffirst(df[[var]], na.rm = TRUE))) {
        stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
        
        
        # Check if conversion failed (if it's still not POSIXct)
        if (!inherits(df[[var]], "POSIXct")) {
          stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
          
        }
        
      }
    }
    print(paste("Woohoo",var,"is in the correct dttm format!!"))
  }
  
  # Join with cohort data and glimpse the result
  df <- df %>% 
    right_join(df_cohort_keep) %>% 
    glimpse()
  
  # Assign the dataframe to a new variable in the global environment named after the file_name
  assign(x, df, envir = .GlobalEnv)
}


```




