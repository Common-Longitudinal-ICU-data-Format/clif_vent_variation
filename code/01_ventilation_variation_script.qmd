---
title: "01_ventilation_variation_script"
author: Nick Ingraham
date: today
execute: 
  echo: false
format: 
  html:
    embed-resources: true
    number-sections: true
    toc: true
    html-q-tags: true
    code-fold: true
editor: source
editor_options: 
  chunk_output_type: console
---

# CLIF Setup
```{r}
# Install renv if not already installed:
# if (!requireNamespace("renv", quietly = TRUE)) {
#   install.packages("renv")
# }

# renv::activate()
# renv::restore()
```


```{r}
# # Initialize renv for the project:
# renv::init(bare = TRUE, settings = list(use.cache = FALSE))
# 
# # Install required packages:
# renv::install("BiocManager")
# BiocManager::install("IRanges")
# 
# # renv::update()
# renv::install(c("tidyverse", "ggthemes", "systemfonts",  "styler", "readxl", "writexl", "DBI", "dbplyr", "knitr", "pandoc", "janitor", "data.table", "duckdb" ,"powerjoin", "collapse", "tidyfast", "datapasta", "fst", "dtplyr", "bit64", "zoo", "fuzzyjoin", "arrow", "hrbrthemes", "here", "table1", "rvest", "tidymodels", "pscl", "survminer"))
# 
# #, dependencies = TRUE
#  # "KMsurv"
# # Save the project's package state:
# renv::snapshot()


```

### Libraries

```{r}
#| label: installing packages
#| timeit: true


packages <- c("tidyverse", "ggthemes", "systemfonts",  "styler", "readxl", "writexl", "DBI", "dbplyr", "knitr", "janitor", "pandoc", "data.table", "duckdb" ,"powerjoin", "collapse", "tidyfast", "datapasta", "fst", "dtplyr", "bit64", "zoo", "fuzzyjoin", "arrow", "hrbrthemes", "here", "table1", "rvest", "tidymodels", "pscl", "survival", "survminer")
# 
# install_if_missing <- function(package) {
#   if (!require(package, character.only = TRUE)) {
#     renv::install(package, dependencies = TRUE)
#     library(package, character.only = TRUE)
#   }
# }

load_function <- function(package) {
    library(package, character.only = TRUE)
}

sapply(packages, load_function)

```


### Utils

```{r}
# Load the configuration utility
source("utils/config.R")

# Access configuration parameters
site_name <- config$site_name
tables_path <- config$tables_path
file_type <- config$file_type


# Print the configuration parameters
print(paste("Site Name:", site_name))
print(paste("Tables Path:", tables_path))
print(paste("File Type:", file_type))



# List of all table names from the CLIF 2.0 ERD
tables <- c(
  "patient",
  "hospitalization",
  "vitals",
  "labs",
  "medication_admin_continuous",
  "adt",
  "patient_assessments",
  "respiratory_support",
  "position",
  "dialysis",
  "intake_output",
  "ecmo_mcs",
  "procedures",
  "admission_diagnosis",
  "provider",
  "sensitivity",
  "medication_orders",
  "medication_admin_intermittent",
  "therapy_details",
  "microbiology_culture",
  "sensitivity",
  "microbiology_nonculture"
  )

# Tables that should be set to TRUE for this project
true_tables <- c(
  "hospitalization",
  "vitals",
  "labs",
  "medication_admin_continuous",
  "adt",
  # "patient_assessments",
  "respiratory_support",
  "position",
  # "dialysis",
  # "intake_output",
  # "ecmo_mcs",
  # "procedures",
  # "admission_diagnosis",
  # "provider",
  # "sensitivity",
  # "medication_orders",
  # "medication_admin_intermittent",
  # "therapy_details",
  # "microbiology_culture",
  # "sensitivity",
  # "microbiology_nonculture",
  "patient"
  )

# Create a named vector and set the boolean values
table_flags <- setNames(tables %in% true_tables, tables)


# List all CLIF files in the directory
clif_table_filenames <- list.files(path = tables_path, 
                                   pattern = paste0("^clif_.*\\.", file_type, "$"), 
                                   full.names = TRUE)

# Extract the base names of the files (without extension)
clif_table_basenames <- basename(clif_table_filenames) %>%
  str_remove(paste0("\\.", file_type, "$"))

# Create a lookup table for required files based on table_flags
required_files <- paste0("clif_", names(table_flags)[table_flags])

# Check if all required files are present
missing_tables <- setdiff(required_files, clif_table_basenames)
if (length(missing_tables) > 0) {
    stop(paste("Missing required tables:", 
               paste(missing_tables, collapse = ", ")))
}

# Filter only the filenames that are required
required_filenames <- clif_table_filenames[clif_table_basenames %in% required_files] 


```


### Functions

```{r}
#| label: Functions
#| timeit: true


# Quickly look at the data like we would in stata, default is 100
ni_peek <- function(x, n=100){
  view(head(x, n))
}

# check missing variables
ni_count_missing <- function(df, group_vars, x_var) {
  df |> 
    group_by(pick({{ group_vars }})) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
    )
}
# flights |>  count_missing(c(year, month, day), dep_time)

# look at the variables
ni_check_variables <- function(df, n=500) {
  check <- tibble(
    col_name = names(df), 
    col_type = map_chr(df, vctrs::vec_ptype_full),
    n_miss = map_int(df, \(x) sum(is.na(x)))
  )
  print(check, n=n)
}

ni_count_prop <- function(df, var, sort = TRUE) {
  df |>
    count({{ var }}, sort = sort) |>
    mutate(prop = n / sum(n)
    )
}

# Identify and create a table of duplicate rows based on clif_hospitalizations_joined_id
ni_duplicate_finder <- function(df, group_vars = c(clif_hospitalizations_joined_id), n=1){
df |> 
  dplyr::group_by(pick({{ group_vars }})) |> 
  filter(n() > {{ n }}) |> 
  ungroup()
}

ni_tic <- function() {
  .GlobalEnv$time_start_temp <- proc.time()
  .GlobalEnv$time_start_sys <- Sys.time()
  return(Sys.time())
}

ni_toc <- function() {
  time_end_sys <- Sys.time()
  .GlobalEnv$time_diff.time <- round(time_end_sys - time_start_sys,2)
  mylist <- list(time_diff.time, cat("Finished in",timetaken(time_start_temp),"\n"
             ))
return(print(mylist[[1]]))
}

fio2warning <- function() {
  warning("fio2 variable needed to be fixed, it was multiplied by 100!!!")
}

labwarning <- function() {
  warning("lab values are character and needed to be fixed, they were forced to numeric!!!")
}

vitalwarning <- function() {
  warning("vital values are character and needed to be fixed, they were forced to numeric!!!")
}



read_data <- function(file_path) {
  file_path_temp <- paste0(tables_path,"/", file_path, ".", file_type)
  print(file_path_temp)
  
  if (grepl("\\.csv$", file_path_temp)) {
    return(read.csv(file_path_temp) 
    )
    
  } else if (grepl("\\.parquet$", file_path_temp)) {
    return(arrow::open_dataset(file_path_temp)  |> 
             collect()
    )
    
  } else if (grepl("\\.fst$", file_path_temp)) {
    return(fst::read.fst(file_path_temp) 
    )
  } else {
    stop("Unsupported file format")
  }
}

# for quick opening and filtering...
#     ni_open_dataset_clif(adt) |> filter(patient_id == "asdf") |> collect() |> View()
ni_open_dataset_clif <- function(file){
    file_quoted <- deparse(substitute(file))
 open_dataset(paste0(tables_path, "/",  "clif_", file_quoted, ".parquet"), thrift_string_size_limit = 1000000000) |> 
      mutate(across(where(is.character), as.character)) |> 
      mutate(across(where(is.character), str_to_lower)) 
}

```

# Import

## Cohort identification

```{r}
#~~~~~~~~~~
# ID cohort
#~~~~~~~~~~


## Date range
start_date <- "2020-01-01"
end_date <- "2021-12-31"


# Main Respiratory Support Table
#~~ using readr or fst or arrow (parquet) package depending on the file type. (THESE WERE SET DURING SET UP ^^ )
clif_respiratory_support_start <- 
  read_data("clif_respiratory_support") |> 
  select(hospitalization_id, device_category, tracheostomy, recorded_dttm) |> 
# Just getting those ventilated or trach
  filter(str_to_lower(device_category) == "imv" | tracheostomy == 1) 
    
clif_hospitalization_start <- 
  read_data("clif_hospitalization") |> 
  select(hospitalization_id, admission_dttm, discharge_dttm, age_at_admission, patient_id, admission_name, admission_category, discharge_name, discharge_category)


# getting a keep_list of hospitalization_ids that have vent or trach during their encounter... we will use this right_join the dfs below
# Update 10/2024... 
#     need to just use patient_id for now 
#     because we need to get hsopitalizations_joined_id first 
#     before we pair down to the hospitalizations we want to keep 
df_cohort_keep_start <- clif_respiratory_support_start |> 
  

# Exclusion based on date
  left_join(clif_hospitalization_start) |>
  filter(
    lubridate::date(admission_dttm) >= start_date,
    lubridate::date(admission_dttm) <= end_date,
# age exclusion
    age_at_admission >= 18,
# missing data exclusion
    !is.na(age_at_admission)
    ) |>  
  select(patient_id) |> 
  distinct()


# shrinking down to just the patients that meet criteria
clif_hospitalization_start <- clif_hospitalization_start |> 
  right_join(df_cohort_keep_start) 


```



## Fixing Hospitalization

```{r}
#Create an Hospital Block ID - This is to Identify Continuous Hospitalizations When Patients Are Transferred Between Hospitals in One Health System
#This code is intended be robust to various ways encounters may be coded in CLIF databases
hospital_blocks <- clif_hospitalization_start |> 
  select(patient_id, hospitalization_id, admission_dttm, discharge_dttm) |>
  arrange(patient_id, admission_dttm) |>
  collect()

#Identify Admissions That Occur Within 3 Hours of a Discharge (Will Consider Those Linked and as Part of One Continuous Encounter)
#Use Data Table for Speed
linked_encounters <- setDT(hospital_blocks)
#Create a Variable for the time of the next admission and time of previous discharge
linked_encounters[, ':=' (next_admit_dttm = data.table::shift(admission_dttm, n=1, type = "lead")), by = patient_id]
linked_encounters[, ':=' (prev_dc_dttm = data.table::shift(discharge_dttm, n=1, type = "lag")), by = patient_id]
#Calculates Time Between Discharge and Next Admit
linked_encounters[, next_diff_time := difftime(next_admit_dttm, discharge_dttm, units = "hours")]
linked_encounters[, prev_diff_time := difftime(admission_dttm, prev_dc_dttm, units = "hours")]

#Now Create Variable Indicating a Linked Encounter (next_admit-dc time <6 hours or prev_dc-admint <6 hours)
linked_encounters[, linked := fcase(
  (next_diff_time <6 | prev_diff_time <6), 1)]
#Filter to Only Linked Encounters and number them
linked_encounters <- linked_encounters[linked==1]
#This Identifies the First Encounter in a Series of Linked Encounters
linked_encounters[, first_link := fcase(
  (rowid(linked)==1 | (next_diff_time<6 & prev_diff_time>6)), 1
), by = patient_id]

#Now Numbers Encounters, easier in dplyr
#Filter to Just First Links, Number them and then Remerge with linked encounters
temp <- as_tibble(linked_encounters) |>
  filter(first_link==1) |>
  group_by(patient_id) |>
  mutate(link_group=row_number()) |>
  ungroup() |>
  select(hospitalization_id, link_group) 
linked_encounters <- as_tibble(left_join(linked_encounters, temp)) |>
  fill(link_group, .direction = c("down")) |>
  #Create a Variable Indicating Which Number of LIinked Encounter the Encounter is
  group_by(patient_id, link_group) |>
  mutate(link_number=row_number()) |>
  ungroup() |>
  select(hospitalization_id, linked, link_number)
rm(temp)

#Now Join Back to Hospitalization Table
clif_hospitalization_start <- clif_hospitalization_start |>
  left_join(linked_encounters) |>
  mutate(linked=if_else(is.na(linked), 0, linked)) |>
  compute()

#Pull Out the Any Linked Encounter that Is NOt the First Encounter and Assign Each Encounter an Encounter Block ID in the Original clif_hospitalization table
df_link <- clif_hospitalization_start |>
  filter(link_number>1) |>
  collect()

clif_hospitalization <- clif_hospitalization_start |>
  group_by(patient_id) |>
  arrange(patient_id, admission_dttm) |>
  #Remove Link Numbers that Are Not First in Link Encounter
  filter(link_number==1 | is.na(link_number)) |>
  #Make Encounter Blocks
  collect() |>
  mutate(encounter_block=row_number()) |>
  rowbind(df_link, fill = TRUE) |> #Bring Back in Link Numbers >1
  group_by(patient_id) |> arrange(patient_id, admission_dttm) |>
  fill(encounter_block, .direction = "down") |>
  ungroup()|>
  #Finally, for Linked Encounters Identify 'Final_admit_date' and 'final_dc_date' which are the first and last dates of a link block
  group_by(patient_id, encounter_block) |>
  mutate(final_admission_dttm=fcase(
    row_number()==1, admission_dttm
  )) |>
  mutate(final_discharge_dttm=fcase(
    row_number()==n(), discharge_dttm
  )) |>
  mutate(final_admission_name=fcase(
    row_number()==1, admission_name
  )) |>
  mutate(final_discharge_name=fcase(
    row_number()==n(), discharge_name
  )) |>
  mutate(final_admission_category=fcase(
    row_number()==1, admission_category
  )) |>
  mutate(final_discharge_category=fcase(
    row_number()==n(), discharge_category
  )) |>
  mutate(clif_hospitalizations_joined_id = cur_group_id()) |> 
  fill(starts_with("final_"), .direction = 'updown') |>
  
  select(
    clif_hospitalizations_joined_id,
    hospitalization_id,
    patient_id,
    encounter_block,
    age_at_admission,
    admission_dttm = final_admission_dttm,
    discharge_dttm = final_discharge_dttm,
    admission_name = final_admission_name,
    discharge_name = final_discharge_name,
    admission_category = final_admission_category,
    discharge_category = final_discharge_category
  ) |> 
  ungroup() |> 
  as_arrow_table() |> 
  collect()



```

### Final cohorting with fixed clif_hospitalizations_joined_id
```{r}
# need to get the joined encounters taht we need to keep... then we will make a final keep with 
#     clif_hospitalizations_joined_id, hospitalization_id, patient_id
df_cohort_keep_encounters <- 
  # These are just patient_ids 
  df_cohort_keep_start |> 

# redo inclusion/exclusion with new admit dates and d/c dates
# Getting hospitaliaztion_ids and such with new variables made above
# Exclusion based on date
  left_join(clif_hospitalization) |>
  filter(
    lubridate::date(admission_dttm) >= start_date,
    lubridate::date(admission_dttm) <= end_date,
# age exclusion
    age_at_admission >= 18,
# missing data exclusion
    !is.na(age_at_admission)
    ) |>  
# these are JUST hospitalizations with imv or trach... we are using this to ID the joined_ids that we need to keep
  inner_join(clif_respiratory_support_start |> select(hospitalization_id) |> distinct()) |> 
  select(clif_hospitalizations_joined_id) |> 
  distinct()

df_cohort_keep <- clif_hospitalization |> 
  inner_join(df_cohort_keep_encounters) |> 
  select(clif_hospitalizations_joined_id, hospitalization_id, patient_id) |> 
  distinct()
  

# narrowing down clif_hospitaliation to the appropriate cohort
clif_hospitalization <- clif_hospitalization |> 
  inner_join(df_cohort_keep_encounters)
  
  
  
```


### Importing function

```{r}
#~~~~~~~~~~
# Importing function
#~~~~~~~~~~

# Function for importing files easily just with the file of the clif_table
import_df <- function(x) {
  # Construct the file path
  file_path <- paste0(tables_path,"/", x, ".", file_type)
  
  # Dynamically call the appropriate read function based on file_type
  
  if (file_type == "parquet") {
    
    read_function <- get(paste0("open_dataset")) 
    
    df <- read_function(file_path) |>
      
      # helps with glitch in open_dataset
      mutate(across(where(is.character), as.character)) |> 
      
      # right join early so files are smaller
      right_join(df_cohort_keep) |> 
      
      # unfactor things to ensure everything is lowercase
      mutate(across(where(is.factor), as.character)) |> 
      
      # get everything to lower
      mutate(across(where(is_character), str_to_lower)) |> 
      
      # only need if using open dataset
      collect()
    
  } else {
    
    read_function <- get(paste0("read_", file_type)) 
    
    df <- read_function(file_path) |>
      
      # right join early so files are smaller
      right_join(df_cohort_keep) |> 
      
      # unfactor things to ensure everything is lowercase
      mutate(across(where(is.factor), as.character)) |> 
      
      # get everything to lower
      mutate(across(where(is_character), str_to_lower)) 
    
  }
  
  
  # Find all datetime variables containing 'dttm'
  datetime_vars <- names(df)[grepl("dttm", names(df))]
  
  # Check and convert datetime variables
  for (var in datetime_vars) {
    if (!inherits(df[[var]], "POSIXct")) {
      
      # Attempt to parse datetime using a common format, adjust based on your actual format
      df[[var]] <- ymd_hms(df[[var]], quiet = TRUE)
      
      # Check if it just turned things into NA
      if (is.na(ffirst(df[[var]], na.rm = TRUE))) {
        stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
        
        
        # Check if conversion failed (if it's still not POSIXct)
        if (!inherits(df[[var]], "POSIXct")) {
          stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
          
        }
        
      }
    }
    print(paste("Woohoo",var,"is in the correct dttm format!!"))
  }
  
  # Join with cohort data and glimpse the result
  df %>% glimpse()
  
  # Assign the dataframe to a new variable in the global environment named after the file_name
  assign(x, df, envir = .GlobalEnv)
}




# List all objects in the global environment
all_objects <- ls()

# Identify objects ending with "_start"
df_start_objects <- grep("_start$", all_objects, value = TRUE)

# Remove identified objects
rm(list = df_start_objects)
gc()

```



### Importing tables

```{r}

#~~~~~~~~~~
# Import data and cohort tables
#~~~~~~~~~~


# Resp support table cohort
clif_respiratory_support <- import_df("clif_respiratory_support") |> 
      # Check if Variables match!!
      # You will get an error if you do not have all the relevant variables needed
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        recorded_dttm,
        device_name,
        device_category,
        mode_name,
        mode_category,
        fio2_set,
        lpm_set,
        tidal_volume_set,
        resp_rate_set,
        pressure_control_set, # not used
        pressure_support_set,
        flow_rate_set,  # not used
        # peak_inspiratory_pressure_set, # not used and only in infants
        inspiratory_time_set, # not used
        peep_set,
        tidal_volume_obs,
        plateau_pressure_obs,
        peak_inspiratory_pressure_obs,
        mean_airway_pressure_obs,
        # peep_obs, # not used and not in adult set 
        minute_vent_obs,
        tracheostomy)


# ADT File to merge with patient so we can get hospital ID
clif_adt <- import_df("clif_adt") |> 
      # Check if Variables match!!
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        location_name,
        location_category,
        in_dttm,
        out_dttm,
        hospital_id)

# Vitals to merge with patient so we can get BMI, height, spo2 information
clif_vitals <- import_df("clif_vitals") |> 
      # Check if Variables match!!
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        recorded_dttm,
        vital_name,
        vital_category,
        vital_value,
        meas_site_name)


# GCS for lap2
clif_gcs <- import_df("clif_gcs") |> 
      # Check if Variables match!!
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        recorded_dttm,
        gcs_eye,
        gcs_verbal,
        gcs_motor,
        gcs_total
        )

# Labs to merge with patient so we can get pao2 all lap2 needs
clif_labs <- import_df("clif_labs") |> 
      # Check if Variables match!!
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        lab_order_dttm,
        lab_result_dttm,
        lab_collect_dttm,
        lab_name,
        lab_category,
        lab_order_category,
        lab_value_numeric,
        reference_unit,
        lab_type_name) |> 
  arrange(clif_hospitalizations_joined_id, hospitalization_id, lab_collect_dttm, lab_category, lab_value_numeric) |> 
  
  # get rid of duplicates
  #     will take the first non-missing lab_value_numeric
  distinct(clif_hospitalizations_joined_id, hospitalization_id, lab_collect_dttm, lab_category, .keep_all = TRUE)
  

# Demographics 
clif_patient <- import_df("clif_patient") |> 
      # Check if Variables match!!
      select(
        clif_hospitalizations_joined_id, hospitalization_id,
        patient_id,
        sex_category,
        race_category,
        ethnicity_category,
        death_date) |> 
  arrange(patient_id, sex_category) |> 
  # account for possible "male" and "unknown" documentation. very race.  taking male > unknown 
  # distinct will slice the top one.
  distinct(clif_hospitalizations_joined_id, hospitalization_id, patient_id, .keep_all = TRUE) 


# THIS IS DONE ALREADY ABOVE!!
# # Encounter Information 
# clif_hospitalization <- import_df("clif_hospitalization") |>
#       # Check if Variables match!!
#       select(clif_hospitalizations_joined_id, hospitalization_id,
#              patient_id,
#              # admission_category, # don't have this yet in CLIF
#              admission_dttm,
#              discharge_dttm,
#              discharge_category,
#              discharge_name,
#              age_at_admission)



# combining them to one df
clif_demographics_combined <- clif_patient |> 
  left_join(clif_hospitalization) 



# # Procedures (don't need for now, just for checking trach data at some point)
# clif_procedures <- import_df("clif_procedures") |>
#       # Check if Variables match!!
#       c(clif_hospitalizations_joined_id, hospitalization_id,
#         procedure_name,
#         start_time,
#         hcup_category)     # UMN variable... may want to implement in CLIF... just need to link HCUP table to PX codes

```

# Import QA checks

```{r}

# Check fio2_set
fio2_mean <- mean(clif_respiratory_support$fio2_set, na.rm = TRUE) 

# fixing if its less than one
# You will get a warning but it will be fixed on its own with IF statement
if(fio2_mean < 1){ 
  fio2warning()
  clif_respiratory_support <- clif_respiratory_support |> mutate(fio2_set = fio2_set * 100)
}


# Check Values of labs and vitals
if(is.character(clif_labs$lab_value_numeric)){
  labwarning()
  clif_labs <- clif_labs |> 
    mutate(lab_value_numeric = as.numeric(parse_number(lab_value_numeric)))
}


# Check Values of labs and vitals
if(is.character(clif_vitals$vital_value)){
  vitalwarning()
  clif_vitals <- clif_vitals |> 
    mutate(vital_value = as.numeric(parse_number(vital_value)))
}

```



# Cleaning Data

## Hourly Sequence

```{r}
#| label: cleaning up vent data


#~~~~~~~~~~~~~~~~
##~~ getting an hour sequence so we can fill in the gaps
#~~~~~~~~~~~~~~~~
## This is just encounter ID and recorded times at xx:59:59
## data that occurs last in the hour when there are multiple data points 
## in the end ... we will want this to be the data we use to fill the next hour... if time is NOT unified... you could have hour sequence that is 12:01, 1:01 everywhere and even when there IS data you risk filling in from the hour before and not getting the NEW data during that hour.
# if we set all the new seq hours to 59:59 then you can fill those in without risking other data when you fill in and do distinct (take the first of the hour for everything).  Remember.  Even hours with 1 data will have a new hour seq row that may be before or after the data... so doing the 59:59 puts it at the end!!!
# 

ni_tic()
hour_sequence <- clif_respiratory_support |> 
  group_by(clif_hospitalizations_joined_id)  |> 
  reframe(recorded_dttm = seq(fmin(recorded_dttm), fmax(recorded_dttm), by = "1 hour")) |> 
  # Adjust to the last second of the hour using lubridate's floor_date
  mutate(recorded_dttm = floor_date(recorded_dttm, "hour") + minutes(59) + seconds(59)) |> 
  # Create date and hour columns efficiently
  mutate(recorded_date = as_date(recorded_dttm),
         recorded_hour = hour(recorded_dttm))
ni_toc()

```



## Quality Check & Clean + Waterfall

```{r}
#~~~~~~~~~~~~~~~~
##~~ Quick QA and fixing missing values throughout
#~~~~~~~~~~~~~~~~
ni_tic()
df_resp_support_1  <- clif_respiratory_support |> 
  select(clif_hospitalizations_joined_id, hospitalization_id, recorded_dttm, device_category, device_name, mode_category, mode_name, 
         fio2_set, lpm_set, tidal_volume_set, peep_set,  pressure_support_set, resp_rate_set, tracheostomy, 
         tidal_volume_obs, peak_inspiratory_pressure_obs, minute_vent_obs, plateau_pressure_obs, mean_airway_pressure_obs 
  ) |>
  
  # filter is recorded_dttm missing
  mutate(
    # fio2_set
    fio2_set = fcase(fio2_set > 100, NA_real_, rep_len(TRUE, length(fio2_set)), fio2_set),
    fio2_set = fcase(fio2_set <  21, NA_real_, rep_len(TRUE, length(fio2_set)), fio2_set),
    
    # Set tidal_volume_set
    tidal_volume_set = fcase(tidal_volume_set > 2500, NA_real_, rep_len(TRUE, length(tidal_volume_set)), tidal_volume_set),
    tidal_volume_set = fcase(tidal_volume_set <   50, NA_real_, rep_len(TRUE, length(tidal_volume_set)), tidal_volume_set),
    
    # peep_set
    peep_set = fcase(peep_set > 30, NA_real_, rep_len(TRUE, length(peep_set)), peep_set),
    peep_set = fcase(peep_set <  0, NA_real_, rep_len(TRUE, length(peep_set)), peep_set),
    
    # pressure_support_set (sometimes APRV may be in here ... so limit ~ 50??)
    pressure_support_set = fcase(pressure_support_set > 50, NA_real_, rep_len(TRUE, length(pressure_support_set)), pressure_support_set),
    pressure_support_set = fcase(pressure_support_set <  0, NA_real_, rep_len(TRUE, length(pressure_support_set)), pressure_support_set),
    
    # resp_rate_set
    resp_rate_set = fcase(resp_rate_set > 60, NA_real_, rep_len(TRUE, length(resp_rate_set)), resp_rate_set),
    resp_rate_set = fcase(resp_rate_set <  0, NA_real_, rep_len(TRUE, length(resp_rate_set)), resp_rate_set),
    
    # tidal_volume_obs
    tidal_volume_obs = fcase(tidal_volume_obs > 2500, NA_real_, rep_len(TRUE, length(tidal_volume_obs)), tidal_volume_obs),
    tidal_volume_obs = fcase(tidal_volume_obs <    0, NA_real_, rep_len(TRUE, length(tidal_volume_obs)), tidal_volume_obs),
    
    # peak_inspiratory_pressure_obs
    peak_inspiratory_pressure_obs = fcase(peak_inspiratory_pressure_obs > 60, NA_real_, rep_len(TRUE, length(peak_inspiratory_pressure_obs)), peak_inspiratory_pressure_obs),
    peak_inspiratory_pressure_obs = fcase(peak_inspiratory_pressure_obs <  0, NA_real_, rep_len(TRUE, length(peak_inspiratory_pressure_obs)), peak_inspiratory_pressure_obs),
    
    # minute_vent_obs
    minute_vent_obs = fcase(minute_vent_obs > 30, NA_real_, rep_len(TRUE, length(minute_vent_obs)), minute_vent_obs),
    minute_vent_obs = fcase(minute_vent_obs <  0, NA_real_, rep_len(TRUE, length(minute_vent_obs)), minute_vent_obs),
    
    # mean_airway_pressure_obs
    mean_airway_pressure_obs = fcase(mean_airway_pressure_obs > 60, NA_real_, rep_len(TRUE, length(mean_airway_pressure_obs)), mean_airway_pressure_obs),
    mean_airway_pressure_obs = fcase(mean_airway_pressure_obs <  0, NA_real_, rep_len(TRUE, length(mean_airway_pressure_obs)), mean_airway_pressure_obs),
    
    ) |>
  
  # getting data and hour information
  mutate(recorded_date = date(recorded_dttm),
         recorded_hour = hour(recorded_dttm)) |> 
  
  # getting hospital ID for each hour
  dplyr::left_join( #tidy_table doesn't like it when you use join_by() with between (Dropped tidy_table 2_2024) 
    clif_adt |> 
      select(clif_hospitalizations_joined_id, hospital_id, location_name, location_category, in_dttm, out_dttm),
    by = join_by(clif_hospitalizations_joined_id, between(recorded_dttm, in_dttm, out_dttm))
  ) |> 

  # order for filling things in
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  

  
  # Fixing when: the mode and category are there with device_name and device_cat not filled in.  fixing with the below
  mutate(
    device_category = 
      fcase(
        is.na(device_category) & is.na(device_name) &
          str_detect(mode_category, "assist control-volume control|simv|pressure control"),
        "imv",
            rep_len(TRUE, length(device_category)), device_category
      ),
    device_name = 
      fcase(
        str_detect(device_category, "imv") & is.na(device_name) &
          str_detect(mode_category, "assist control-volume control|simv|pressure control"),
        "mechanical ventilator",
        rep_len(TRUE, length(device_name)), device_name
        
      ),
  ) |>
  
  # fixing other vent things
  #     If device before is VENT + normal vent things ... its VENT too 
  mutate(device_category = fcase(is.na(device_category) & 
                                     lag(device_category == "imv") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "imv", 
                                   rep_len(TRUE, length(device_category)), device_category)) |>
  
  #     If device after is VENT + normal vent things ... its VENT too 
  mutate(device_category = fcase(is.na(device_category) & 
                                     lead(device_category == "imv") & 
                                     tidal_volume_set > 1 & 
                                     resp_rate_set > 1 & 
                                     peep_set > 1, 
                                   "imv", 
                                   rep_len(TRUE, length(device_category)), device_category)) |>
  
  # same as above for device_name ^^^^^^^^^^^
  mutate(device_name = fcase(is.na(device_name) & lag(device_category == "imv") & tidal_volume_set > 1 & resp_rate_set > 1 & peep_set > 1, 
                             "mechanical ventilation", 
                             rep_len(TRUE, length(device_name)), device_name)) |> 
  
  mutate(device_name = fcase(is.na(device_name) & lead(device_category == "imv") & tidal_volume_set > 1 & resp_rate_set > 1 & peep_set > 1, 
                             "mechanical ventilation", 
                             rep_len(TRUE, length(device_name)), device_name)) |> 
  
  
  # doing this for BiPAP as well 
  mutate(device_category = fcase(is.na(device_category) & 
                                     lag(device_category == "nippv") & 
                                     minute_vent_obs > 1 & 
                                     peak_inspiratory_pressure_obs > 1 & 
                                     pressure_support_set > 1, 
                                   "nippv", 
                                   rep_len(TRUE, length(device_category)), device_category)) |>
  
  mutate(device_category = fcase(is.na(device_category) & 
                                     lead(device_category == "nippv") & 
                                     minute_vent_obs > 1 & 
                                     peak_inspiratory_pressure_obs > 1 & 
                                     pressure_support_set > 1, 
                                   "nippv", 
                                   rep_len(TRUE, length(device_category)), device_category)) |>
  
  

  # there are times when its clearly back to CMV (resp set and volume is set but no one puts a mode back in... just leaves it blank)
  # this is usually after pressure support ... we need to classify this now as CMV. 
  # only exception to this should be when it says trach
  # There are also some without device_cat or name and they have all the variables... these should be changed too 
  mutate(
    device_category = 
      fcase(
        is.na(device_category) & 
          !str_detect(device_name, "trach") &
          tidal_volume_set > 0 & 
          resp_rate_set > 0,
        "imv",
        rep_len(TRUE, length(device_category)), device_category),
    device_name = 
      fcase(
        is.na(device_name) & 
          !str_detect(device_name, "trach") &
          tidal_volume_set > 0 & 
          resp_rate_set > 0,
        "mechanical ventilator",
        rep_len(TRUE, length(device_name)), device_name),
    mode_category = 
      fcase(
        is.na(mode_category) & 
          !str_detect(device_name, "trach") &
          tidal_volume_set > 0 & 
          resp_rate_set > 0,
        "assist control-volume control",
        rep_len(TRUE, length(mode_category)), mode_category),
    mode_name = 
      fcase(
        is.na(mode_name) & 
          !str_detect(device_name, "trach") &
          tidal_volume_set > 0 & 
          resp_rate_set > 0,
        "cmv/ac",
        rep_len(TRUE, length(mode_name)), mode_name)
  ) |> 
  
  
  # when there are duplicate times...
  group_by(clif_hospitalizations_joined_id, recorded_dttm) |> 
  
  # when bipap is part of a duplicate we need to get rid of it... 
  #     its usually when a vent is STARTED and device is carried over but it goes to a new line with lots of NAs
  #     the NA line above has the vent settings.  Its best to just drop the nippv line when its a duplicate
  #     if we don't do this... the vent settings get sent backwards across all bipap

  mutate(n = n()) |>  
  filter(
    #  essentially this is... DROP if n>1 and device_cat == nippv
    !(n > 1 & device_category == "nippv")) |> 
  
  # redo n so we keep vent settings from above... now NAs are bad around other things and we should just drop
  mutate(n = n()) |> 
  filter(
    #  essentially this is... DROP if n>1 and device_cat == NA
    !(n > 1 & is.na(device_category))) |> 
  

  
  # filter if missing everything  
  filter(
    #  essentially this is... DROP if everything missing
    !(is.na(device_category) & 
        is.na(device_name) &
        is.na(mode_category) &
        is.na(mode_name) & 
        is.na(fio2_set) &        # keeps informative fio2_set data around
        is.na(tidal_volume_set)    # keeps vent data around... this happens sort of often
      )) |> 
    
    

  # dropping duplicates for everything else but just taking the first one
  #       ffirst works WAY faster than fill up and down and slicing(1)
  ffirst() |> 
  ungroup() |> # technically don't need this  
    
  ###########
  # TEMP STOP #
  ungroup()
  ###########
  ###########

ni_toc()

```

# check this person 40937
```{r}

ni_tic()

df_resp_support <- df_resp_support_1 |> 
  
# bring in hour sequences
  bind_rows(hour_sequence) |> 


#~~~~~~~~~~~~~~~~
##~~ Filling in data based on a waterfall of categories to ensure accuracy
#~~~~~~~~~~~~~~~~
  # organizing
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  relocate(clif_hospitalizations_joined_id, recorded_dttm, recorded_date, recorded_hour) |> 
  
  # fill forward device category
  group_by(clif_hospitalizations_joined_id) |> 
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  fill(device_category) |>
  ungroup() |> 
  
  # Record a new device_category when either (a) a new encounter, or (b) preceded by a...   
  # different device category
  mutate(
    # need to have NA as something so it gets an ID
    device_cat_f = fcase(is.na(device_category), "missing", rep_len(TRUE, length(device_category)), device_category), # cant have anything with NAs when factoring
    device_cat_f = as.integer(as.factor(device_cat_f)), # need an integer for this
    
    # getting IDs
    device_cat_id = fcumsum((
      clif_hospitalizations_joined_id != flag(clif_hospitalizations_joined_id, fill = TRUE) |           # (a)
        device_cat_f  != flag(device_cat_f, fill = TRUE)))) |>       # (b)
  
  relocate(device_cat_id, .after = recorded_hour) |> 
  
  # fill device name
  #         changed some failsafes above 4/2024 so its ok to do downup with this now
  group_by(clif_hospitalizations_joined_id, device_cat_id) |> 
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  fill(device_name, .direction = "downup") |> 
  ungroup() |>
  
  
  # Record a new device_id when either (a) a new encounter, or 
  #                                    (b) preceded by a different device name.
  mutate(
    # need to have NA as something so it gets an ID
    device_name_f = fifelse(is.na(device_name), "missing", device_name), # cant have anything with NAs when factoring
    device_name_f = as.integer(as.factor(device_name_f)), # need an integer for this
    
    # getting IDs
    device_id = fcumsum((
      clif_hospitalizations_joined_id    != flag(clif_hospitalizations_joined_id, fill = TRUE) |           # (a)
        device_name_f != flag(device_name_f, fill = TRUE)))) |>      # (b)
  
  relocate(device_id, .after = recorded_hour) |> 
  
  # fill mode_category (downup)
  # there are PST that are being carried over to days before when ppl get REINTUBATED
  group_by(clif_hospitalizations_joined_id, device_id) |> 
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  fill(mode_category, .direction = "downup") |> 
  ungroup() |> 
  
  # Create mode_id
  mutate(
    mode_cat_f = fifelse(is.na(mode_category), "missing", mode_category), # cant have anything with NAs when factoring
    mode_cat_f = as.integer(as.factor(mode_cat_f)), # need an integer for this
    
    mode_cat_id = fcumsum((
      device_id     != flag(device_id, fill = TRUE) |        # (a)
        mode_cat_f  != flag(mode_cat_f, fill = TRUE)))) |>   # (b)
  
  
  relocate(mode_cat_id, .after = recorded_hour) |> 
  
  # fill mode name (downup) 
  group_by(clif_hospitalizations_joined_id, mode_cat_id) |> 
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  fill(mode_name, .direction = "downup") |> 
  ungroup() |>  
  
  # Create mode name id
  mutate(
    mode_name_f = fifelse(is.na(mode_name), "missing", mode_name), # cant have anything with NAs when factoring
    mode_name_f = as.integer(as.factor(mode_name_f)), # need an integer for this
    
    mode_name_id = fcumsum((
      mode_cat_id != flag(mode_cat_id, fill = TRUE) |               # (a)
        mode_name_f != flag(mode_name_f, fill = TRUE)))) |>         # (b)
  
  relocate(mode_name_id, .after = recorded_hour) |> 
  
  
  # changing fio2_set to 0.21 if room air as category
  mutate(fio2_set = if_else(is.na(fio2_set) & device_category == "room air", 21, fio2_set)) |> 
  
  # erroneous set volumes are in places where they shouldn't be for PS and trach_dome
  mutate(
    tidal_volume_set = fifelse(
      (
        mode_category == "pressure support/cpap" &    # needs to be PS/CPAP
          !is.na(pressure_support_set)                    # needs to have a PS level
      ) |
        (
          is.na(mode_category) &                      # mode cat needs to be NA
            str_detect(device_name, "trach")          # only when trach stuff
        ) |
        (
          mode_category == "pressure support/cpap" &  # needs to be PS/CPAP
            str_detect(device_name, "trach")          # only when trach stuff
        ),
      NA_integer_,
      tidal_volume_set),
    
    
  ) |>
  
  # there are ppl with t-piece that should be blow_by
  mutate(mode_category = fifelse(
    (is.na(mode_category) & 
       str_detect(device_name, "t-piece")),
    "blow by",
    mode_category
  )) |> 
  
  # carry forward the rest
  group_by(clif_hospitalizations_joined_id, mode_name_id) |>  # mode_name_id is the most granular, can go up and down
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  
  # took trach out of this so we don't fill back up 3/2024
  fill(c(fio2_set, lpm_set, peep_set, tidal_volume_set, pressure_support_set, resp_rate_set, tidal_volume_obs, peak_inspiratory_pressure_obs,  minute_vent_obs, 
         hospital_id, location_name, location_category, in_dttm, out_dttm
  ), .direction = "downup"
  ) |>
  
  # fill trach... only down
  fill(c(tracheostomy), .direction = "down") |>
  ungroup() |> 
  
  # need to get rid of duplicates 
  distinct() |> 
  select(
    clif_hospitalizations_joined_id,
    recorded_dttm,
    recorded_date,
    recorded_hour,
    mode_name_id,
    device_category,
    device_name,
    mode_category,
    mode_name,
    mode_cat_id,
    device_id,
    device_cat_id,
    fio2_set,
    lpm_set,
    peep_set,
    tracheostomy,
    tidal_volume_set,
    pressure_support_set,
    resp_rate_set,
    tidal_volume_obs,
    mean_airway_pressure_obs,
    peak_inspiratory_pressure_obs,
    plateau_pressure_obs,
    # obs_resp_rate,
    minute_vent_obs,
    hospital_id,
    location_name,
    location_category,
    # in_dttm,
    # out_dttm,
    # device_cat_f,
    # device_name_f,
    # mode_cat_f,
    # mode_name_f,
  ) 

ni_toc()
```


### intermediate save

```{r}

### remaining issues
# [ ]  Issue with what to do when there are PS numbers with Trach Dome... should we show it as PS or leave blank



df_resp_support |> glimpse() 
# df_resp_support |> count(device_category, device_name) |> arrange(-n) |> print(n=1000)
# df_resp_support |> count(mode_category, mode_name) |> arrange(-n)
# df_resp_support |> count(device_category, device_name, mode_category, mode_name) |> arrange(-n)
# df_resp_support |> filter(is.na(device_category)) |> count(device_category, device_name, mode_category, mode_name) |> ni_peek(1000)


## this is just a stopping point so you can come back and work below 
## just run things before "Cleaning Data" and you can start below if its been saved once!


## # saving system date today
most_recent_save_resp <- Sys.Date()
save(most_recent_save_resp, file = "output/intermediate/most_recent_save_resp.Rdata")


write_parquet(df_resp_support, paste0("output/intermediate/df_resp_support_.",Sys.Date() ,".parquet"))


```



## Vitals / ibw / labs

```{r}


######################
##~~ clean vitals and get ibw
######################

# quickly get back to things without doing the above
if(!exists("df_resp_support")){
  load("output/intermediate/most_recent_save_resp.Rdata")

  df_resp_support <- read_parquet(paste0("output/intermediate/df_resp_support_", most_recent_save_resp,".parquet"))
}

##~~~~~~~~~~~~~
##~~ spo2
##~~~~~~~~~~~~~

df_spo2 <- clif_vitals |> 
  
  # getting spo2
  filter(vital_category == "spo2") |> 
  
  # making those columns
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm),
    names_from = vital_category,
    values_from = vital_value,
    values_fn = function(x) mean(x, na.rm = TRUE)
  ) |> 
  
  # getting date so we can group by this
  mutate(recorded_date = date(recorded_dttm),
         recorded_hour = hour(recorded_dttm)) |> 
  
  # taking the min spo2 by  DAY and HOUR and ENCOUNTER 
  group_by(clif_hospitalizations_joined_id, recorded_date, recorded_hour) |> 
  summarize(spo2 = fmin(spo2, na.rm = TRUE)) |> 
  ungroup() |> 
  select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, spo2)
  

##~~~~~~~~~~~~~
##~~ po2_arterial / so2_arterial
##~~~~~~~~~~~~~

df_po2_arterial <-  clif_labs |> 
    filter(lab_category %in% c("po2_arterial",
                             "so2_arterial")) |> 
  # going to use collected_time and not result time because its important when doing PF ratios
  # also important because we are doing daily LAPS2, so its key is when its collected
  select(clif_hospitalizations_joined_id, recorded_dttm = lab_collect_dttm, lab_category, lab_value_numeric) |>

  # getting po2_arterial / so2_arterial
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm),
    names_from = lab_category,
    values_from = lab_value_numeric,
    values_fn = function(x) mean(x, na.rm = TRUE)
  ) |> 
  
    # getting date so we can group by this
  mutate(recorded_date = date(recorded_dttm),
         recorded_hour = hour(recorded_dttm)) |> 
  
  # grouping by day
  group_by(clif_hospitalizations_joined_id, recorded_date) |> 
  summarize(po2_arterial = fmin(po2_arterial, na.rm = TRUE),
            so2_arterial = fmin(so2_arterial, na.rm = TRUE)
            ) |> 
  ungroup() |> 
      # getting date so we can group by this
  mutate(recorded_hour = hour(recorded_date)) |> 
  select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, po2_arterial, so2_arterial)

##~~~~~~~~~~~~~
##~~ ibw
##~~~~~~~~~~~~~

df_ibw <- clif_vitals |> 
  
  # getting height and spo2
  filter(vital_category == "height_cm") |> 
  mutate(height_in = vital_value / 2.54) |> 
  # 
  # # making those columns
  # pivot_wider(
  #   id_cols = c(clif_hospitalizations_joined_id, recorded_dttm),
  #   names_from = vital_category,
  #   values_from = vital_value,
  #   values_fn = function(x) mean(x, na.rm = TRUE)
  # ) |> 
  
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 

  group_by(clif_hospitalizations_joined_id) |> 
  
  # taking the first height DAY and ENCOUNTER
  summarise(height_in = ffirst(height_in, na.rm = TRUE)) |> 
  ungroup() |> 
  
  # get biological sex_category
  left_join(clif_patient |> 
             select(clif_hospitalizations_joined_id, sex_category)
            ) |> 
  
  # Calculate ibw for males
  mutate(ibw = fifelse(sex_category == "male" & height_in > 56, 50 + (2.3 * (height_in - 60)), NA_real_)) |>  # 1st % of male = 60 inches
  
  # Calculate ibw for females
  mutate(ibw = fifelse(sex_category == "female" & height_in > 56, 45.5 + (2.3 * (height_in - 60)), ibw)) |>  # 1st % of female = 56 inches
  
  # Remove records with height less than 40
  # This also removes those without a height for the whole admission, which is ok... can't do LTVV without height known
  filter(height_in >= 40) |>  # assumming these are kiddos and/or amputees which means IBW will be inaccurate
  group_by(clif_hospitalizations_joined_id) |> 
  
  # using first ibw for the encounter
  mutate(ibw = ffirst(ibw, na.rm = TRUE)) |> 
  
  # getting only the variables we want
  select(clif_hospitalizations_joined_id, ibw, sex_category) |> 
  ungroup() |> 
  distinct()


```


## Trach Variation

```{r}

   # getting trach hospital (first one with trach == 1)
trach_hospital_id <- df_resp_support |> 
  filter(tracheostomy == 1) |> 
  select(clif_hospitalizations_joined_id, recorded_date, trach_hospital_id = hospital_id) |> 
  arrange(clif_hospitalizations_joined_id, recorded_date) |> 
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(trach_hospital_id = ffirst(trach_hospital_id)) |> 
  select(clif_hospitalizations_joined_id, trach_hospital_id) |> 
  distinct() 

  # get the first trach day by encounter only
trach_day1 <- df_resp_support |> 
  filter(tracheostomy == 1) |> 
  select(clif_hospitalizations_joined_id, recorded_date) |> 
  arrange(clif_hospitalizations_joined_id, recorded_date) |> 
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(trach_day1 = fmin(recorded_date, na.rm = TRUE)) |> 
  select(clif_hospitalizations_joined_id, trach_day1) |> 
  distinct() 

  # get the first ventilator day by encounter only
vent_day1 <- df_resp_support |> 
  filter(device_category == "imv") |> 
  select(clif_hospitalizations_joined_id, recorded_date) |> 
  arrange(clif_hospitalizations_joined_id, recorded_date) |> 
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(vent_day1 = fmin(recorded_date, na.rm = TRUE)) |> 
  select(clif_hospitalizations_joined_id, vent_day1) |> 
  distinct() 
  
df_trach_variation <- df_resp_support |> 
  # keep encounters that have a tracheostomy
  mutate(tracheostomy_max = fmax(tracheostomy, na.rm = TRUE),
         .by = clif_hospitalizations_joined_id) |> 
  filter(tracheostomy_max == 1) |> 
  
  # getting vent days or trach days ONLY
  filter(device_category == "imv" | tracheostomy == 1) |> 
  
  select(clif_hospitalizations_joined_id, recorded_date, tracheostomy) |> 
  distinct() |> 
  
  arrange(clif_hospitalizations_joined_id, recorded_date) |> 
  
  # getting vent day count
  ungroup() |> 
  
  # getting vent day count because some ppl might have days OFF the vent in between if we just do min(vent_day)
  group_by(clif_hospitalizations_joined_id) |> 
  
  # this will give 1, 2, 3, 4, 5 as long as its the same clif_hospitalizations_joined_id and trach is NA
  # once trach == 1 it parks at that max number so we can just take max
  # also... we can drop those with vent_day_count == 0 because that means they had the trach on vent day 1!!!
  mutate(vent_day_count = fcumsum(
    is.na(tracheostomy)
  )) |> 
  left_join(trach_day1) |> 
  left_join(vent_day1) |> 
  left_join(trach_hospital_id) |> 
  
  # get rid of those with zero vent_day_count (aka they were trached the whole time)
  filter(vent_day_count > 0) |> 
  select(clif_hospitalizations_joined_id, trach_hospital_id, trach_day1, vent_day1, vent_day_count) |> 
  mutate(vent_day_count_max = max(vent_day_count, na.rm = TRUE)) |> 
  
  # true "trach_day" is vent_day_count_max - 1 because we didn't have a vent_day_zero... we started at 1
  mutate(vent_days_before_trach = vent_day_count_max - 1) |> 
  
  mutate(
  trach_day = difftime(trach_day1, vent_day1, units = "days")
    ) |>
  select(clif_hospitalizations_joined_id, trach_hospital_id, vent_days_before_trach) |> 
  ungroup() |>
  distinct()

df_trach_variation |> glimpse()



#### should we get earliest trach and DROP everything after?
  
```


## CLIF hourly level data

```{r}

##~~~~~~~~~~~~~
##~~ Hourly Data
##~~~~~~~~~~~~~

df_hourly_resp_support1 <- df_resp_support |> 
  mutate(recorded_month = month(recorded_dttm),
         recorded_year = year(recorded_dttm)) |> 
  
  #~~ use recorded time to arrange these in order
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  
  # change recorded_dttm to be the same thing at the end of the hour so we can do calculations later
  group_by(clif_hospitalizations_joined_id, recorded_date, recorded_hour) |> 
  mutate(recorded_dttm_hour_end = flast(recorded_dttm)) |> 
  ungroup() |> 
  
  #~~ vent sequence variable
      # only go up in number if (a) new category & (b) its a vent category
      # could add a gap to this as well for like hours and such
  arrange(clif_hospitalizations_joined_id, recorded_date) |> 
  mutate(gap_vent_hours = fifelse(
    device_category == "imv" | tracheostomy == 1,
    as.numeric(difftime(lead(recorded_dttm_hour_end), recorded_dttm_hour_end, units = "hours")),
    NA_real_
  )) |> 
  
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(
    device_category_f = fifelse(is.na(device_category), "missing", device_category), # cant have anything with NAs when factoring
    device_category_f = as.integer(as.factor(device_category_f)), # need an integer for this
    
    # you step to the next vent sequence if
    #    1) its a vent
    #    2) its a NEW device cat
    #    3) trach is na
    #    4) gap is <= 6 between current and LEAD vent hours
    vent_episode_id = fcumsum(
      device_category == "imv" & 
        flag(device_category_f, fill = TRUE) != device_category_f &
        is.na(tracheostomy) & 
        gap_vent_hours <= 6    # this deals with the difference between the lead and the current vent_hours
      )) |> 
  ungroup() 

df_hourly_resp_support2 <- df_hourly_resp_support1 |> 
  
  # currently those with trach right away are zeros for vent_id
  # those without vent or were subsequent after vent are currently the same number as the vent before
  mutate(
    # change those not with trach/vent to NA
    vent_episode_id = fifelse(
      device_category == "imv" | tracheostomy == 1,
      vent_episode_id,
      NA_real_
    ),
    
    # we could also drop these patients if we wanted to 
    # change those trach'd on day1 without vent beforehand to enc_sequence 1
    vent_episode_id = fifelse(
      tracheostomy == 1 & vent_episode_id == 0,
      1,
      vent_episode_id
    )
  ) |> 
  
  # getting vent hour per sequence
  group_by(clif_hospitalizations_joined_id, vent_episode_id) |> 
  mutate(vent_episode_hour_seq = fcumsum(
    recorded_dttm_hour_end != flag(recorded_dttm_hour_end, fill = TRUE))
  ) |>
  # fix those not vent back to NA
  mutate(vent_episode_hour_seq = fifelse(is.na(vent_episode_id), NA_real_, vent_episode_hour_seq)) |> 
  
  
  # get max hours per vent sequence... want to drop those <=24
  mutate(vent_episode_duration_hours = fmax(vent_episode_hour_seq, na.rm = TRUE)) |>
  
  ungroup() |> 
  
  # getting vent hour per sequence per hospital
  #   there are times when that episode crosses hospitals
  #   for hospital summary we need duration split up by hospital
  group_by(clif_hospitalizations_joined_id, vent_episode_id, hospital_id) |> 
  mutate(vent_episode_hospital_hour_seq = fcumsum(
    recorded_dttm_hour_end != flag(recorded_dttm_hour_end, fill = TRUE))
  ) |> 
  
  
  # fix those not vent back to NA
  mutate(vent_episode_hospital_hour_seq = fifelse(is.na(vent_episode_id), NA_real_, vent_episode_hospital_hour_seq)) |> 
  
  
  # get max hours per vent sequence... want to drop those <=24
  mutate(vent_episode_hospital_duration_hours = fmax(vent_episode_hospital_hour_seq, na.rm = TRUE)) |>
  
  ungroup() |> 
  

  # final variables
  select(
  clif_hospitalizations_joined_id,
  recorded_date,
  recorded_hour,
  recorded_dttm_hour_end,
  vent_episode_id,
  vent_episode_hour_seq,
  vent_episode_duration_hours,
  vent_episode_hospital_hour_seq,
  vent_episode_hospital_duration_hours,
  # recorded_dttm,
  device_category,
  device_name,
  mode_category,
  mode_name,
  fio2_set,
  recorded_month,
  recorded_year,
  peep_set,
  tracheostomy,
  tidal_volume_set,
  hospital_id,
  location_name,
  location_category,
  pressure_support_set,
  resp_rate_set,
  tidal_volume_obs,
  mean_airway_pressure_obs,
  peak_inspiratory_pressure_obs,
  plateau_pressure_obs,
  # obs_resp_rate,
  minute_vent_obs,
  ) |>
  
  #~~ group by hour so that we can take the first time point to get our information
  # this will only keep the first row if there are duplicates
  distinct(clif_hospitalizations_joined_id, recorded_date, recorded_hour, .keep_all = TRUE) |> 
  left_join(df_ibw) |> 
  left_join(df_spo2) |> 
  
  # those without ibw need to be dropped... they won't have biological sex either (this drops whole encounters)
  filter(!is.na(ibw)) |> 
  
  group_by(clif_hospitalizations_joined_id) |>
  arrange(clif_hospitalizations_joined_id, recorded_dttm_hour_end) |> 

  
  # getting each hour in sequence of their hospital stay
  mutate(enc_hour_seq = fcumsum(recorded_dttm_hour_end != flag(recorded_dttm_hour_end, fill = TRUE))) |>
  
  # getting the CALENDAR sequence... purely based on date... so day 1 can be 3 hours
  mutate(enc_calendar_date_seq = fcumsum(recorded_date != flag(recorded_date, fill = TRUE))) |>
  
  # getting DAY sequence based on which hour it is... so everyone will be 24 hours in for day 1 etc
  # Will mainly use this metric to use
  mutate(enc_day_seq = ceiling(enc_hour_seq/24)) |> 
  ungroup() |> 
  
  # merge trach variation data
  left_join(df_trach_variation) |> 
  filter(!is.na(hospital_id))


ni_toc()
  
df_hourly_resp_support <- df_hourly_resp_support2 |> 
   # final variables
    select(
      clif_hospitalizations_joined_id,
      recorded_date,
      recorded_hour,
      # recorded_dttm_hour_end,
      vent_episode_id,
      vent_episode_hour_seq,
      vent_episode_duration_hours,
      vent_episode_hospital_hour_seq,
      vent_episode_hospital_duration_hours,
      device_category,
      device_name,
      mode_category,
      mode_name,
      fio2_set,
      recorded_month,
      recorded_year,
      peep_set,
      tracheostomy,
      tidal_volume_set,
      hospital_id,
      location_name,
      location_category,
      ibw,
      sex_category,
      spo2,
      enc_hour_seq,
      enc_calendar_date_seq,
      enc_day_seq,
      trach_hospital_id,
      vent_days_before_trach
      )


# duplicate check
# df_hourly_resp_support |> group_by(pick(colnames(df_hourly_resp_support))) |> filter(n() > 1) 

write_parquet(df_hourly_resp_support, paste0("output/intermediate/df_hourly_resp_support_", Sys.Date(), ".parquet"))

# saving system date today
most_recent_save_hourly <- Sys.Date()
save(most_recent_save_hourly, file = "output/intermediate/most_recent_save.Rdata")

```





## Fig 1 Mode Variation --> Frequency and Density of Vent Mode by hospitals

```{r}

if(!exists("df_hourly_resp_support")){
  load("output/intermediate/most_recent_save_hourly.Rdata")
  df_hourly_resp_support <- read_parquet(paste0(
    "output/intermediate/df_hourly_resp_support_", most_recent_save_hourly,".parquet"))
}


##~~~~~~~~~~~~~
##~~ Hospital Summary
##~~~~~~~~~~~~~

## data should be at the hourly level for each patient encounter
# Calculate normalized counts
mode_hospital_summary_table <- df_hourly_resp_support |> 
  filter(device_category == "imv" & location_category == "icu") |> 
  filter(!is.na(mode_category)) |> 
  group_by(hospital_id) |> 
  summarise(count = n()) |> 
  # Normalizing counts
  mutate(normalized_count = count / fmax(count, na.rm = TRUE),
         # need to have NA in the data given its in the universal aesthetic
         mode_category = NA)  |> 
  arrange(-count) |> 
  ungroup()

write_parquet(mode_hospital_summary_table, paste0("output/final/mode_hospital_summary_table",site_name,".parquet"))


##~~~~~~~~~~~~~
##~~ Graph df
##~~~~~~~~~~~~~

mode_hourly_resp_support <- df_hourly_resp_support |> 
    filter(
      # recorded_year == 2019 &
      device_category == "imv" &  
        location_category == "icu"  # take out operating room ventilation
    ) |> 
    
    filter(!is.na(mode_category)) |>   # only 0.7% for vent device
   mutate(
      mode_category = fct_infreq(mode_category),
      hospital_id_graph = fct_infreq(hospital_id)
    ) |> 
  select(hospital_id_graph, mode_category)

mode_hourly_resp_support_table <- mode_hourly_resp_support |> 
  count(hospital_id_graph, mode_category)
  
test_mode <- mode_hourly_resp_support_table |> 
  uncount(n) 

write_parquet(mode_hourly_resp_support_table, paste0("output/intermediate/mode_hourly_resp_support_table_",site_name,".parquet"))

```


```{r}


# Nick will run the below on the table you saved with all data together
# ... so no need to save the graph
# Left the code  so you can explore your own data

# Create a bar plot with ggplot2
ggplot(
  mode_hourly_resp_support,  aes(x = hospital_id_graph, fill = mode_category)) +
  geom_bar(position = "fill") +
  # Use labs to add a title and remove the axis labels
  labs(title = "Ventilator Modes by Hospital", x = "Hospital", y = "Proportion of Mode Category") + 
  # Use theme_minimal to create a minimal theme
  theme_minimal() +
  # adjusting tick marks for x axis
  theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust = 1)) +
  # Add the summary data as a layer with a dummy aesthetic for color
  geom_point(data = mode_hospital_summary_table, aes(x = hospital_id, y = normalized_count, color = "Total Counts"), size = 3) +
  # Add horizontal lines at the height of each point, only spanning the width of the bar
  geom_errorbar(data = mode_hospital_summary_table, aes(x = hospital_id, ymin = normalized_count, ymax = normalized_count, group = 1, color = "Total Counts"),
                width = 0.9,  # Adjust this value to change the width of the horizontal lines
                linewidth = 0.5) +  # Adjust size for line thickness
  # geom_line(data = mode_hospital_summary_table, aes(x = hospital_id_graph, y = normalized_count, group = 1, color = "Total Counts"), linewidth = 1) +
  # Customize the legend for the dummy aesthetic
  scale_color_manual(name = "Legend", values = c("Total Counts" = "black"),
                     labels = c("Total Counts" = "Total Mode Counts (Normalized)")) +
  guides(fill = guide_legend(title = "Ventilator Mode Category", override.aes = list(color = NA)), 
         color = guide_legend(title = "")) +
  scale_fill_discrete(breaks = c("assist control-volume control", 
                                 "pressure support/cpap", 
                                 "pressure-regulated volume control",
                                 "pressure control", 
                                 "simv", 
                                 "blow by"))






```

## Fig 2 Trach Variation --> Estimated Day of ventilation of Trach placement by hospitals

```{r}

# clean up trach days
 trach_variation <- df_hourly_resp_support |> 
  filter(!is.na(vent_days_before_trach)) |> 
  select(clif_hospitalizations_joined_id, trach_hospital_id, vent_days_before_trach) |> 
  ungroup() |>
  distinct()


trach_variation_table <- trach_variation |>
  count(trach_hospital_id, vent_days_before_trach)
  
test_trach <- trach_variation_table |> 
  uncount(n) 

write_parquet(trach_variation_table, paste0("output/final/trach_variation_table_",site_name,".parquet"))

```


```{r}

# Nick will run the below on the table you saved with all data together
# ... so no need to save the graph
# Left the code  so you can explore your own data
# 
# 
trach_excl_early_trach <- trach_variation |> filter(vent_days_before_trach > 3)

# Create a boxplot
ggplot(trach_variation, aes(x = trach_hospital_id, y = vent_days_before_trach)) +
  geom_boxplot() +
  labs(title = "Variation in Tracheostomy Ventilator Day Across Hospitals",
       x = "Hospital",
       y = "Ventilator Day for Tracheostomy")


# Create a violin plot
ggplot(trach_variation, aes(x = trach_hospital_id, y = vent_days_before_trach)) +
  geom_violin() +
  labs(title = "Variation in Tracheostomy Ventilator Day Across Hospitals",
       x = "Hospital",
       y = "Ventilator Day for Tracheostomy")


ggplot(trach_variation, aes(x = trach_hospital_id, y = vent_days_before_trach, fill = factor(trach_hospital_id))) +
  # geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) + # Hide outliers for the boxplot
  # geom_jitter(width = 0.2, size = 1.5, alpha = 0.4) +
  geom_violin(adjust = 2) +
  labs(title = "Variation in Tracheostomy Ventilator Day Across Hospitals",
       x = "Hospital",
       y = "Ventilator Day for Tracheostomy") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  # theme_light() +
  guides(fill = guide_legend(title = "Hospital ID"))


# trach_variation |> filter(vent_days_before_trach > 30) |> View()

```


## Fig 3 Initial Set Volume / ibw Variation 

```{r}

ltvv_variation <- df_hourly_resp_support |> 
  # keep only those on vent and exclude non-icu times
  filter(device_category == "imv" & location_category == "icu") |> 
  
  # need at least 24 hours of ventilation
  filter(vent_episode_duration_hours >= 24) |> 
  
  # getting Vt by ibw
  mutate(vt_cckg = tidal_volume_set / ibw) |> 
  
  mutate(vt_bin = case_when(
    vt_cckg <  4            ~"< 4 cc/kg",
    vt_cckg <  5            ~"4-5 cc/kg",
    vt_cckg <  6            ~"5-6 cc/kg",
    vt_cckg <  7            ~"6-7 cc/kg",
    vt_cckg <  8            ~"7-8 cc/kg",
    vt_cckg <  9            ~"8-9 cc/kg",
    vt_cckg <  10           ~"9-10 cc/kg",
    vt_cckg <  11           ~"10-11 cc/kg",
    vt_cckg <  12           ~"11-12 cc/kg",
    vt_cckg >= 12           ~">= 12 cc/kg",
    TRUE                    ~ NA_character_
  )) |> 
  
  mutate(
    vt_bin = factor(vt_bin, levels = rev(c("< 4 cc/kg", "4-5 cc/kg",
                                           "5-6 cc/kg", "6-7 cc/kg",
                                           "7-8 cc/kg" , "8-9 cc/kg",
                                           "9-10 cc/kg", "10-11 cc/kg",
                                           "11-12 cc/kg", ">= 12 cc/kg")))
  ) |> 
  
  # remove those without tidal_volume_sets
  filter(!is.na(tidal_volume_set))


ltvv_variation_table <- ltvv_variation |> 
  count(hospital_id, vt_bin)

test_ltvv <- ltvv_variation_table |> 
  uncount(n) 

write_parquet(ltvv_variation_table, paste0("output/final/ltvv_variation_table_",site_name,".parquet"))
```


```{r}

# Nick will run the below on the table you saved with all data together
# ... so no need to save the graph
# Left the code  so you can explore your own data

icu_hosp_ranks_8cc <- ltvv_variation |> 
  group_by(hospital_id) |> 
  mutate(count_hosp = n()) |> 
  group_by(hospital_id, vt_bin, count_hosp) |> 
  summarise(count_bin = n()) |> 
  ungroup() |>
  filter(vt_bin %in% c("8-9 cc/kg","9-10 cc/kg", "10-11 cc/kg", "11-12 cc/kg", ">= 12 cc/kg")) |> 
  group_by(hospital_id) |> 
  mutate(pct_over_8 = sum(count_bin) / count_hosp) |> 
  select(hospital_id, pct_over_8) |> 
  distinct() |>
  arrange(pct_over_8) |>  
  pull(hospital_id)



ltvv_variation |> 
  filter(hospital_id %in% icu_hosp_ranks_8cc) |> 
  mutate(hospital_id = factor(hospital_id, levels = rev(icu_hosp_ranks_8cc))) |> 
  ggplot(aes(y = hospital_id, fill = vt_bin )) + 
  geom_bar(position = "fill") + 
  scale_fill_brewer(palette = "RdBu", direction = 1) +
  ggthemes::theme_gdocs() + 
  labs(x = "Percentage of patient-hours of volume control ventilation",
       y = "Hospital",
       fill = "")

ggsave("output/intermediate/variation_in_vent_under_8cc_sort.pdf")



```


## Table 1 CLIF patient characteristics

```{r}


#TABLE FUNCTIONS
clif_med = function(v)
{
  a=  paste(round(median(v, na.rm = TRUE), digits =1), " (", deframe(round(quantile(v, na.rm = TRUE), digits =1)[2]), "-", deframe(round(quantile(v, na.rm = TRUE), digits = 1)[4]), ")", sep = "")
  return(a)
}

clif_counts = function(v)
{
  a=  paste(sum(v, na.rm=TRUE), " (", round(mean(v, na.rm=TRUE)*100, digits=1), ")", sep = "")
  return(a)
}

clif_mean_r = function(v)
{
  a=  paste(round(mean(v, na.rm = TRUE), digits=1), " (", round(sd(v, na.rm = TRUE), digits=1), ")", sep = "")
  return(a)
}


clif_demographics_table_start <- df_hourly_resp_support |> 
  select(clif_hospitalizations_joined_id, tracheostomy, hospital_id, vent_episode_id, vent_episode_hospital_duration_hours) |> 
  
  # taking the first round of MV only
  filter((vent_episode_id == 1)) |> 
  select(-vent_episode_id) |> 
  distinct() |> 
  
  # bring in demographics
  left_join(clif_demographics_combined) |> 
  filter(!is.na(age_at_admission)) |> 
  filter(!is.na(hospital_id)) |> 
  # fix forward slashes in hospital
  mutate(hospital_id = str_replace(hospital_id, "/", " ")) |> 
  filter(sex_category %in% c("male", "female"))  |> 
  rename(age = age_at_admission) |> 
  mutate(race_category = fifelse(race_category == "unknown", "other", race_category)) |> 
  mutate(death = as.integer(grepl("dead|expired|death|died", discharge_category, ignore.case = TRUE))) |> 
  mutate(
    
    # fixing up race_category
    race_f = 
      fcase(
        grepl("black|african[-]american", race_category, ignore.case = TRUE)   , "Black",
        grepl("white|caucasian", race_category, ignore.case = TRUE)            , "White",
        grepl("asian", race_category, ignore.case = TRUE)                      , "Asian",
        default                                                       = "Other"
      ),
    
    # fixing up ethnicity_category
    ethnicity_f = 
      fcase(
        grepl("(non|not)[-\\s]*(hispanic|latino|latinx|hisp)", ethnicity_category, ignore.case = TRUE), "Non Hispanic",
        default = "Hispanic"
      )
  ) |> 
  
  # getting max trach for encounter
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(tracheostomy = fmax(tracheostomy, na.rm = TRUE)) |> 
  mutate(tracheostomy = fifelse(tracheostomy == 1, 1, 0, 0)) |> 
  ungroup() |> 
  distinct() |> 
  mutate(across(where(is.character), str_to_title)) |> 
  mutate(across(where(is.character), as.factor))

hospitals <- clif_demographics_table_start |> select(hospital_id) |> distinct() |> pull()

for (hosp in hospitals) {
  clif_demographics_table_start_hosp <- clif_demographics_table_start |> filter(hospital_id == hosp)
  # HTML content (make sure your actual HTML string is correctly input here)
  html_content <- table1(~ age + sex_category + race_category + ethnicity_category + death + tracheostomy + vent_episode_hospital_duration_hours, data = clif_demographics_table_start_hosp)
  
  # Use rvest to read the HTML table
  table <- read_html(html_content) %>%
    html_table(fill = TRUE)
  
  # The first element of the list should be your table
  df <- table[[1]]
  
  # Rename 'Overall(N=14598)' to 'fabc(N=14598)' using the site variable
  names(df) <- gsub("Overall\\(N=(\\d+)\\)", paste0(hosp, ' ', "(N=\\1)"), names(df))
  write.csv(df, paste0("output/intermediate/table1_", hosp, '.csv'), row.names = FALSE)
  
}

# 
# 
# table_summary <- clif_demographics_table_start |> 
#   group_by(hospital_id) |> 
#   summarise(N = n(), 
#             Age               = clif_mean_r(age_at_admission),
#             "Sex, female"     = clif_counts(sex_category == "female"),
#             Race              = "",
#             Black             = paste0("  ", clif_counts(race_category == "black or african-american")),
#             White             = paste0("  ", clif_counts(race_category == "white")),
#             Asian             = paste0("  ", clif_counts(race_category == "asian")),
#             Other             = paste0("  ", clif_counts(!race_category %in% c("black or african-american", "white", "asian"))),
#             "Ethnicity, Hispanic"   = clif_counts(ethnicity_category == "hispanic"),
#             
#             "Ventilator Days" = clif_med(vent_episode_hospital_duration_hours/24),
#             "Mortality"       = clif_counts(death)
#   ) |> 
#   mutate(hospital_id = str_to_title(hospital_id)) |> 
#   rename(Hospital = hospital_id)
# 
# 
# characteristics <- colnames(table_summary)
# # table_summary <- as.data.frame(t(table_summary))
# # characteristics
# 
# # leaving it without transposing it yet
# table_summary
# write_parquet(table_summary, paste0("tables/hospital_table_summary_",site_name,".parquet"))


```


## Men vs Women Tidal Volume Ventilation

```{r}

ltvv_female <- ltvv_variation |> 
  left_join(clif_demographics_combined |> select(sex_category, clif_hospitalizations_joined_id)) |> 
  filter(!sex_category == "Unknown") 

  
ltvv_variation |> 
  filter(hospital_id %in% icu_hosp_ranks_8cc) |> 
  mutate(hospital_id = factor(hospital_id, levels = rev(icu_hosp_ranks_8cc), labels = rev(str_to_title(icu_hosp_ranks_8cc)))) |> 
  mutate(sex_category = factor(sex_category,
                      levels = c("male", "female"),
                      labels = c("Male", "Female"))) |> 
  filter(vt_cckg<15) |> 
  
  ggplot(aes(x = hospital_id, y = vt_cckg, fill = sex_category )) + 
  # bw options c("nrd0", "nrd", "ucv", "bcv", "SJ-ste", "SJ-dpi"),
    geom_violin(position="dodge", bw = "bcv", alpha=0.4, trim = TRUE, scale = "width", draw_quantiles = c(0.5)) +
  # scale_fill_brewer(palette = "RdBu", direction = 1) +
  labs(
    title = "Set tidal volume in first 24 hours by hospital",
    x = "Hospital",
    y = "Set Tidal Volume (cc/kg)"
  ) +
      theme_ipsum(axis_title_just = "m",
                  axis_title_size =  15)  +

  # theme_minimal() + # This theme provides a clean and modern look to the plot
  scale_fill_manual(values = c("Male" = "blue", "Female" = "green")) + # Manual colors for gender  
theme(
  legend.title = element_blank(),
  plot.background = element_blank(),
  panel.grid = element_blank(),
  panel.background = element_blank(),
  panel.grid.major = element_blank(), 
               panel.grid.minor = element_blank(),
  axis.title.y = (element_text(margin = margin(r = 20))),
  axis.title.x = (element_text(margin = margin(t = 20)))
)

  

```


# Laps2 Score


## encounter data

```{r}
### change to hospital_icu
clif_adt_hospital <-  clif_adt |>
  mutate(location_category = factor(location_category,
                                    levels = (c("icu", "floor", "ed", "procedural", "other")),
                                    ordered = TRUE)) |> 
  group_by(clif_hospitalizations_joined_id) |> 
  arrange(clif_hospitalizations_joined_id, location_category, in_dttm) |> 
  
  # first one will be ICU
  slice_head(n=1) |> 
  ungroup() |> 
  select(clif_hospitalizations_joined_id,
         hospital = hospital_id)


clif_adt_admit <-  clif_adt |>
  group_by(clif_hospitalizations_joined_id) |> 
  arrange(clif_hospitalizations_joined_id, in_dttm) |> 
  slice_head(n=1) |> 
  ungroup() |> 
  select(clif_hospitalizations_joined_id,
         first_location_category = location_category)
  

# fixing clif_labs to recorded_dttm
if ("lab_collect_dttm" %in% colnames(clif_labs)) {
  clif_labs <- clif_labs |> rename(recorded_dttm = lab_collect_dttm)
}

df_encounter_laps2_temp1 <- clif_hospitalization |> 
  left_join(clif_patient) |> 
  left_join(clif_adt_hospital) |> 
  left_join(clif_adt_admit) |> 
  
  # make dead/hospice column
  mutate(
    death_or_hospice_01 = fcase(
      discharge_category %in% 
        c("hospice", "dead", "expired", "died")       , 1,
      default                                         = 0
    ),
    
    death_or_hospice_01       = as.factor(death_or_hospice_01),
    
    # make 24 hours after admission variable (to collect data from first 24 hours)
    dt_24hours_after_admit    = admission_dttm + hours(24),
    
    # ED binary variable
    ed_admit_01               = fifelse(str_detect(first_location_category, "ed"), 1, 0, 0),
          # I think we used categorical in Rachel Kohn paper... Pat uses ED y/n
          # admission source OR you can use ED variable
    # Admit source variable (use one or the other)
    # admission_category      = as.factor(admission_category),  don't have this yet
    
    # sex_category
    female_01                 = fifelse(str_detect(sex_category, "female"), 1, 0, 0),
    
  )


```

## prelaps

```{r}

############
# Pre-Laps... want the most recent within 24 hours of admission
############
df_pre_laps2_prep1 <- 
  df_encounter_laps2_temp1 |> 
  left_join(clif_labs |> 
              filter(lab_category %in% c("anion_gap",
                                         "carbon_dioxide", # FROM BMP
                                         "bun",
                                         "creatinine",
                                         "sodium")),
            
            # join only if between the first 24 hours
            by = join_by(clif_hospitalizations_joined_id, 
                         dt_24hours_after_admit >= recorded_dttm) 
  ) |> 
  # Min/Max
  #     bun            max
  #     creatinine     min
  #     bun/cr         max
  #     bun/cr         most recent (prelaps)
  #     anion_gap      max
  #     carbon_dioxide min
  #     ag/bicarb      most recent (prelaps)
  #     sodium         min
  #     sodium         most recent (prelaps)
       
  group_by(clif_hospitalizations_joined_id, recorded_dttm, lab_category) |> 
  # using obs lets you get away with duplicates when going wider and can fix later!
  mutate(obs = row_number()) |> 
  ungroup() |> 
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm, obs),
    names_from = lab_category,
    values_from = lab_value_numeric,
    # names_prefix = "lab_wide_",
    # values_fill = NA
  ) |>
  
  # Quick min/max for duplicates at the SAME time
  select(-obs) |> 
  distinct() 

# find the duplicates by recorded_dttm
df_pre_laps2_prep2 <- df_pre_laps2_prep1 |> 
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  group_by(clif_hospitalizations_joined_id, recorded_dttm) |>
  # mutate(n = n()) |> 
  # filter(n > 1) |> 
  summarise(
    bun               = fmax(bun, na.rm = TRUE),
    creatinine        = fmin(creatinine, na.rm = TRUE),
    carbon_dioxide    = fmin(carbon_dioxide, na.rm = TRUE),
    anion_gap         = fmax(anion_gap, na.rm = TRUE),
    sodium            = fmin(sodium, na.rm = TRUE),

    .groups = "drop"
  ) |> 
  
  # replace inf with NAs
  mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 
  
  # get rid of duplicate rows
  distinct() |> 

# df_pre_laps2_prep2 <- df_pre_laps2_prep1 |> 
#   anti_join(df_pre_laps2_duplicates |> 
#               select(clif_hospitalizations_joined_id, recorded_dttm),
#             join_by(clif_hospitalizations_joined_id, recorded_dttm)) |> 
#   bind_rows(df_pre_laps2_duplicates) |> 
  
  # order appropriately for when getting last labs for "most recent"
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  
  # carry forward
  group_by(clif_hospitalizations_joined_id) |> 
  
  # fill in ... its only the first 24 hours so its ok
  fill(c(bun,
         creatinine,
         carbon_dioxide,
         anion_gap,
         sodium), 
       .direction = "downup") |>
  
  # ? time shift if needed
  
  # get the most recent lab (aka last) based on recorded_dttm
    mutate(
      bun_recent                = flast(bun),
      creatinine_recent         = flast(creatinine),
      carbon_dioxide_recent     = flast(carbon_dioxide),
      anion_gap_recent          = flast(anion_gap),
      sodium_recent             = flast(sodium)
           ) |> 
  ungroup() |> 
  select(clif_hospitalizations_joined_id, ends_with("recent")) |> 

  # final pre-laps labs needed
  mutate(
    # make ratios
    sodium              = sodium_recent,
    bun_cr_ratio        = bun_recent/creatinine_recent,
    ag_hco3_ratio       = (anion_gap_recent/carbon_dioxide_recent)*1000
  ) |> 
  select(-ends_with("recent")) |> 
  
  # replace inf with NAs (sometimes it happens when divided by zero)
  mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 
  
  distinct()
  



# replacing all the admission values that are missing with normal values
        # replace BUNCREAT_RECENT_24=8 if BUNCREAT_RECENT_24==. // 4724
        # replace NA_RECENT_24=135 if NA_RECENT_24==. // 4270
        # replace AGHCO3_RECENT_24=200 if AGHCO3_RECENT_24==. // 5103
        
 df_pre_laps_merging <- df_pre_laps2_prep2 |> 
   left_join(
     df_encounter_laps2_temp1 |> 
       select(
         clif_hospitalizations_joined_id,
         admission_dttm,
         age = age_at_admission,
         female_01,
         ed_admit_01,
         # admission_category,
         death_or_hospice_01
       ) |> 
       distinct(),
     join_by(clif_hospitalizations_joined_id)
   ) |> 
   mutate(
    age_cat = case_when(
      age >= 85 ~ 5,
      age >= 75 ~ 4,
      age >= 65 ~ 3,
      age >= 40 ~ 2,
      TRUE ~ 1
    )
  ) |> 
   mutate(
      # impute to normal (8)
    bun_cr_ratio = fifelse(is.na(bun_cr_ratio), 8, bun_cr_ratio),
     
    buncreat_cat = case_when(
      bun_cr_ratio        >= 24 ~ 4,
      bun_cr_ratio        >= 16 ~ 3,
      bun_cr_ratio        < 8   ~ 2,
      TRUE                      ~ 1
    )
  ) |> 
     mutate(
      # impute to normal (135)
    sodium = fifelse(is.na(sodium), 135, sodium),
    na_cat = case_when(
      sodium            >= 155  ~ 7,
      sodium            >= 149  ~ 6,
      sodium            >= 146  ~ 5,
      sodium            >= 132  ~ 4,
      sodium            >= 129  ~ 3,
      sodium            < 129   ~ 2,
      TRUE                      ~ 1
    )
  ) |> 
     mutate(
      # impute to normal (200)
    ag_hco3_ratio = fifelse(is.na(ag_hco3_ratio), 200, ag_hco3_ratio),
    aghco3_cat = case_when(
      ag_hco3_ratio        >= 600  ~ 4,
      ag_hco3_ratio        >= 400  ~ 3,
      ag_hco3_ratio        < 200   ~ 2,
      TRUE                         ~ 1,
    )
  )
 
 # logistic regression to obtain p(death/hospice)
 lr_model <-
  glm(
    death_or_hospice_01 ~
      age +
      female_01 +
      ed_admit_01 +
      bun_cr_ratio +
      sodium +
      ag_hco3_ratio,
    family = "binomial",
    data   = df_pre_laps_merging
  )

tidy(lr_model)
pR2(lr_model)["McFadden"]

df_pre_laps_final  <- df_pre_laps_merging |> 
  mutate(p_death = predict(lr_model, df_pre_laps_merging, type = "response")) |> 
  mutate(
    high_risk = case_when(
      p_death >= 0.06 ~ 1,
      TRUE ~ 0
    )) %>%
  select(clif_hospitalizations_joined_id, p_death, high_risk)

```


The above has like 58% high risk... that seems too high
See testing below but ultimately I think its ok to use the predictions as above and not the published ones below.  
R2 is 17 (using GLM) vs 11 (using numbers from Escobar study) when doing glm(death ~ p_death) in isolation.  Despite having a high number of high risk (58% with glm vs 10% with escobar numbers), i think it will work out ok


## laps2 labs ALL

```{r}
##~~~~~~~~~~~~~~~~~~~~~
# LAPS2 time
##~~~~~~~~~~~~~~~~~~~~~
 
df_laps2_prep1 <- 
  df_encounter_laps2_temp1 |> 
  select(clif_hospitalizations_joined_id, admission_dttm, discharge_dttm) |> 
  distinct() |> 
  # slice_head(n=1000) |> 
  left_join(clif_labs |> 
              filter(lab_category %in% c("albumin",
                                     "anion_gap",
                                     "bilirubin_total",
                                     "bun",
                                     "carbon_dioxide",
                                     "creatinine",
                                     "glucose_serum",
                                     "hematocrit",
                                     "hemoglobin",
                                     "lactic_acid",
                                     "pco2_arterial",
                                     "po2_arterial",
                                     "ph_arterial",
                                     "platelet_count",
                                     "so2_arterial",
                                     "sodium",
                                     "troponin_i",
                                     "wbc")) |> 
              select(-lab_order_dttm),
            
            # join only if between the first 24 hours
            by = join_by(clif_hospitalizations_joined_id)) |> 
  # making all hemoglobin into hematocrits
  mutate(lab_value_numeric = fifelse(lab_category == "hemoglobin", lab_value_numeric*3, lab_value_numeric)) |> 
  mutate(lab_category = fifelse(lab_category == "hemoglobin", "hematocrit", lab_category)) |> 
  
    # using obs lets you get away with duplicates when going wider and can fix later!
  group_by(clif_hospitalizations_joined_id, recorded_dttm, lab_category) |> 
  mutate(obs = row_number()) |> 
  ungroup() |> 
  
  # pivot wider to get columns
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm, obs),
    names_from = lab_category,
    values_from = lab_value_numeric,
    # names_prefix = "lab_wide_",
    # values_fill = NA
  ) |>
  
  # Quick min/max for duplicates at the SAME time
  select(-obs) |> 
  mutate(lab_date = date(recorded_dttm)) |> 
  distinct() 

ni_tic()
# find the duplicates by day
df_laps2_prep2 <- df_laps2_prep1 |>
  # arrange(clif_hospitalizations_joined_id, recorded_dttm) |>
  group_by(clif_hospitalizations_joined_id, lab_date) |>
  # mutate(n = n()) |>
  # filter(n > 1) |>
  summarise(
    albumin             = fmin(albumin, na.rm = TRUE),
    anion_gap           = fmax(anion_gap, na.rm = TRUE),
    bilirubin_total     = fmax(bilirubin_total, na.rm = TRUE),
    bun                 = fmax(bun, na.rm = TRUE),
    carbon_dioxide      = fmin(carbon_dioxide, na.rm = TRUE),
    creatinine          = fmax(creatinine, na.rm = TRUE),
    glucose_serum       = fmin(glucose_serum, na.rm = TRUE),
    hematocrit          = fmax(hematocrit, na.rm = TRUE),
    lactic_acid         = fmax(lactic_acid, na.rm = TRUE),
    pco2_arterial               = fmax(pco2_arterial, na.rm = TRUE),
    po2_arterial                = fmax(po2_arterial, na.rm = TRUE),
    ph_arterial         = fmin(ph_arterial, na.rm = TRUE),
    platelet_count      = fmin(platelet_count, na.rm = TRUE),
    so2_arterial        = fmin(so2_arterial, na.rm = TRUE),
    sodium              = fmin(sodium, na.rm = TRUE),
    troponin            = fmax(troponin_i, na.rm = TRUE),
    wbc                 = fmin(wbc, na.rm = TRUE
    ), 

    .groups = "drop"
  ) |> 
  
    # bun_cr_ratio
  mutate(
    bun_cr_ratio = bun / creatinine
  ) |> 
  
    mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 
  # get rid of duplicate rows
  distinct() 




# |> 
#   group_by(clif_hospitalizations_joined_id) |> 
#   # carryforward after prelaps imputation
#     fill(c(
#       albumin,
#       anion_gap,
#       bilirubin_total,
#       bun,
#       carbon_dioxide,
#       creatinine,
#       glucose,
#       hematocrit,
#       lactic_acid,
#       pco2_arterial,
#       po2_arterial,
#       ph_arterial,
#       platelet_count,
#       so2_arterial,
#       sodium,
#       troponin,
#       wbc,
#       ), 
#       .direction = "down") |>
  
  ni_toc()


            
```

## Labs day one

```{r}
df_laps2_dayone_prep1 <- 
  df_encounter_laps2_temp1 |> 
  select(clif_hospitalizations_joined_id, admission_dttm, discharge_dttm, dt_24hours_after_admit) |> 
  distinct() |> 
  left_join(clif_labs |> 
              filter(lab_category %in% c("albumin",
                                     "anion_gap",
                                     "bilirubin_total",
                                     "bun",
                                     "carbon_dioxide",
                                     "creatinine",
                                     "glucose_serum",
                                     "hematocrit",
                                     "hemoglobin",
                                     "lactic_acid",
                                     "pco2_arterial",
                                     "po2_arterial",
                                     "ph_arterial",
                                     "platelet_count",
                                     "so2_arterial",
                                     "sodium",
                                     "troponin_i",
                                     "wbc")) |>            
              select(-lab_order_dttm),
            
            # join only if between the first 24 hours
            by = join_by(clif_hospitalizations_joined_id, 
                         dt_24hours_after_admit >= recorded_dttm)
  ) |> 

  # making all hemoglobin into hematocrits
  mutate(lab_value_numeric = fifelse(lab_category == "hemoglobin", lab_value_numeric*3, lab_value_numeric)) |> 
  mutate(lab_category = fifelse(lab_category == "hemoglobin", "hematocrit", lab_category)) |> 
  
  group_by(clif_hospitalizations_joined_id, recorded_dttm, lab_category) |> 
  # using obs lets you get away with duplicates when going wider and can fix later!
  mutate(obs = row_number()) |> 
  ungroup() |> 
  
  # pivot wider to get columns
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm, obs, admission_dttm),
    names_from = lab_category,
    values_from = lab_value_numeric,
    # names_prefix = "lab_wide_",
    # values_fill = NA
  ) |>
  
  # Quick min/max for duplicates at the SAME time
  select(-obs) |> 
  distinct() 

# get min/max
df_laps2_dayone_prep2 <- df_laps2_dayone_prep1 |>
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |> 
  
  # filter out those without a recorded_dttm so we don't add a date later
  filter(!is.na(recorded_dttm)) |> 
  # if we make "lab_date" the encounter date... then we are switching all labs within 24hr of admission to the "day 1" in a sneaky fashion
  mutate(lab_date = date(admission_dttm)) |> # make it all the same day 1
  group_by(clif_hospitalizations_joined_id, lab_date) |>
  # mutate(n = n()) |>
  # filter(n > 1) |>
  summarise(
    albumin             = fmin(albumin, na.rm = TRUE),
    anion_gap           = fmax(anion_gap, na.rm = TRUE),
    bilirubin_total     = fmax(bilirubin_total, na.rm = TRUE),
    bun                 = fmax(bun, na.rm = TRUE),
    carbon_dioxide      = fmin(carbon_dioxide, na.rm = TRUE),
    creatinine          = fmax(creatinine, na.rm = TRUE),
    glucose_serum       = fmin(glucose_serum, na.rm = TRUE),
    hematocrit          = fmax(hematocrit, na.rm = TRUE),
    lactic_acid         = fmax(lactic_acid, na.rm = TRUE),
    pco2_arterial               = fmax(pco2_arterial, na.rm = TRUE),
    po2_arterial                = fmax(po2_arterial, na.rm = TRUE),
    ph_arterial         = fmin(ph_arterial, na.rm = TRUE),
    platelet_count      = fmin(platelet_count, na.rm = TRUE),
    so2_arterial        = fmin(so2_arterial, na.rm = TRUE),
    sodium              = fmin(sodium, na.rm = TRUE),
    troponin            = fmax(troponin_i, na.rm = TRUE),
    wbc                 = fmin(wbc, na.rm = TRUE
    ),

    .groups = "drop"
  ) |> 
  
    # bun_cr_ratio
  mutate(
    bun_cr_ratio = bun / creatinine
  ) |> 
  
    # replace inf with NAs
  mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 

    # get rid of duplicate rows
  distinct() 



# switch out the day 1 stuff 
df_laps2_final <- df_laps2_prep2 |> anti_join(df_laps2_dayone_prep2 |> 
                              select(clif_hospitalizations_joined_id, lab_date)) |> 
  bind_rows(df_laps2_dayone_prep2) |> 
  arrange(clif_hospitalizations_joined_id, lab_date) |> 
  

  # filter out NA for lab date
  filter(!is.na(lab_date))

  
```


## GCS


```{r}



df_gcs_merge_ready <- clif_gcs |>
  mutate(vital_value = case_when(
    gcs_total %in% c(14, 15)                ~ 1,
    gcs_total %in% c(8, 9, 10, 11, 12, 13)  ~ 3,
    gcs_total %in% c(2, 3, 4, 5, 6, 7)      ~ 4,
    TRUE                                    ~ NA   # we account for this when doing the points later
  )) |>
  mutate(vital_category = "gcs") |> 
  select(clif_hospitalizations_joined_id,
         vital_category,
         recorded_dttm,
         vital_value,
         )


df_vitals_gcs <- clif_vitals |>
              filter(vital_category %in% c("temp_c",
                                       "sbp",
                                       "spo2",
                                       "heart_rate",
                                       "respiratory_rate")) |>
              select(-meas_site_name) |> 
              
                          # get gcs in there now
              bind_rows(df_gcs_merge_ready)


```

## vitals all

```{r}

df_laps2_vitals_prep1 <- 
  df_encounter_laps2_temp1 |> 
  select(clif_hospitalizations_joined_id, admission_dttm, discharge_dttm) |>
  distinct() |> 
  left_join(df_vitals_gcs,
            
            # join by the encounter ID
            by = join_by(clif_hospitalizations_joined_id)) |> 
  
    group_by(clif_hospitalizations_joined_id, recorded_dttm, vital_category) |> 
  # using obs lets you get away with duplicates when going wider and can fix later!
  mutate(obs = row_number()) |> 
  ungroup() |> 
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm, obs),
    names_from = vital_category,
    values_from = vital_value,
    # names_prefix = "vital_wide_",
    # values_fill = NA
  ) |>
  
  #fixing temp 
  mutate(temp = (temp_c * (9/5)) + 32) |> 
  
  #renaming resp
  rename(resp = respiratory_rate) |> 
  
  # Quick min/max for duplicates at the SAME time
  select(-obs) |> 
  distinct() 

# find the duplicates by day
df_laps2_vitals_prep2 <- df_laps2_vitals_prep1 |>
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |>
  mutate(vital_date = date(recorded_dttm)) |> 
  group_by(clif_hospitalizations_joined_id, vital_date) |>
  # mutate(n = n()) |>
  # filter(n > 1) |>
  summarise(
    temp                = fmin(temp, na.rm = TRUE),
    sbp                 = fmin(sbp, na.rm = TRUE),
    spo2                = fmin(spo2, na.rm = TRUE),
    heart_rate               = fmax(heart_rate, na.rm = TRUE),
    resp                = fmax(resp, na.rm = TRUE),
    gcs                 = fmax(gcs, na.rm = TRUE),  # remember the groupings... higher is lower gcs
    # shock_index         = fmax(shock_index, na.rm = TRUE),  # do this after

    .groups = "drop"
  ) |> 
  mutate(
    shock_index = heart_rate / sbp
  ) |> 
  # replace inf with NAs
  mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 

  # get rid of duplicate rows
  distinct() 




```


## vitals day one

```{r}


df_laps2_vitals_dayone_prep1 <- 
  df_encounter_laps2_temp1 |> 
  select(clif_hospitalizations_joined_id, admission_dttm, discharge_dttm, dt_24hours_after_admit) |>
  distinct() |> 
  left_join(df_vitals_gcs,
            
            # join only if between the first 24 hours
            by = join_by(clif_hospitalizations_joined_id, 
                         dt_24hours_after_admit >= recorded_dttm)
  ) |> 
  
    group_by(clif_hospitalizations_joined_id, recorded_dttm, vital_category) |> 
  # using obs lets you get away with duplicates when going wider and can fix later!
  mutate(obs = row_number()) |> 
  ungroup() |> 
  pivot_wider(
    id_cols = c(clif_hospitalizations_joined_id, recorded_dttm, obs, admission_dttm),
    names_from = vital_category,
    values_from = vital_value,
    # names_prefix = "vital_wide_",
    # values_fill = NA
  ) |>
  
  #fixing temp 
  mutate(temp = (temp_c * (9/5)) + 32) |> 
  
  #renaming resp
  rename(resp = respiratory_rate) |> 
  
  
  # Quick min/max for duplicates at the SAME time
  select(-obs) |> 
  

  distinct() 

# find the duplicates by day
df_laps2_vitals_dayone_prep2 <- df_laps2_vitals_dayone_prep1 |>
  arrange(clif_hospitalizations_joined_id, recorded_dttm) |>
  
  # filter out those without a recorded_dttm so we don't add a date later
  filter(!is.na(recorded_dttm)) |> 
  
  # if we make "lab_date" the encounter date... then we are switching all labs within 24hr of admission to the "day 1" in a sneaky fashion
  #using encounter admit date to collect everything together
  mutate(vital_date = date(admission_dttm)) |> 
  group_by(clif_hospitalizations_joined_id, vital_date) |>
  # mutate(n = n()) |>
  # filter(n > 1) |>
  summarise(
    temp                = fmin(temp, na.rm = TRUE),
    sbp                 = fmin(sbp, na.rm = TRUE),
    spo2                = fmin(spo2, na.rm = TRUE),
    heart_rate          = fmax(heart_rate, na.rm = TRUE),
    resp                = fmax(resp, na.rm = TRUE),
    gcs                 = fmax(gcs, na.rm = TRUE),
    # shock_index         = fmax(shock_index, na.rm = TRUE),  # do this after

    .groups = "drop"
  ) |> 
  mutate(
    shock_index         = heart_rate / sbp
  ) |> 
  
  # replace inf with NAs
  mutate(across(where(is.numeric) & !c(clif_hospitalizations_joined_id), ~ na_if(.x, is.infinite(.x)))) |> 

  # get rid of duplicate rows
  distinct() 

# switch out the day 1 stuff 
df_laps2_vitals_final <- df_laps2_vitals_prep2 |> anti_join(df_laps2_vitals_dayone_prep2 |> 
                              select(clif_hospitalizations_joined_id, vital_date)) |> 
  bind_rows(df_laps2_vitals_dayone_prep2) |> 
  arrange(clif_hospitalizations_joined_id, vital_date) |> 
  
  # drop rows with no recorded date
  filter(!is.na(vital_date))



```



## Laps2 code

```{r}

df_laps_calc <- df_laps2_final |> 
  # get same naming for date
  rename(recorded_date = lab_date) |> 
  full_join(df_laps2_vitals_final |> 
              rename(recorded_date = vital_date),
            join_by(clif_hospitalizations_joined_id, recorded_date)
            ) |> 
  full_join(df_pre_laps_final)
  
df_laps2_scores <- df_laps_calc |> 
  group_by(clif_hospitalizations_joined_id, recorded_date) |> 
  mutate(
    laps2 = 0,
    # lactic_acid and pH 
    laps2 = fcase(
      
      # missing data
      is.na(ph_arterial)  &                      is.na(lactic_acid) & high_risk == 0 , laps2 + 0,
      is.na(ph_arterial)  &                      is.na(lactic_acid) & high_risk == 1 , laps2 + 15,
      is.na(ph_arterial)  &                      lactic_acid < 2    & high_risk == 0 , laps2 + 0,
      is.na(ph_arterial)  &                      lactic_acid < 2    & high_risk == 1 , laps2 + 12,
      is.na(ph_arterial)  & lactic_acid >= 2   & lactic_acid < 4    & high_risk == 0 , laps2 + 12,
      is.na(ph_arterial)  & lactic_acid >= 2   & lactic_acid < 4    & high_risk == 1 , laps2 + 15,
      is.na(ph_arterial)  &                      lactic_acid >= 4   & high_risk == 0 , laps2 + 26,
      is.na(ph_arterial)  &                      lactic_acid >= 4   & high_risk == 1 , laps2 + 30,
      ph_arterial < 7.2   &                      is.na(lactic_acid) & high_risk == 0 , laps2 + 13,
      ph_arterial < 7.2   &                      is.na(lactic_acid) & high_risk == 1 , laps2 + 19,
      ph_arterial >= 7.2  & ph_arterial < 7.35 & is.na(lactic_acid) & high_risk == 0 , laps2 + 5,
      ph_arterial >= 7.2  & ph_arterial < 7.35 & is.na(lactic_acid) & high_risk == 1 , laps2 + 15,
      ph_arterial >= 7.35 & ph_arterial < 7.45 & is.na(lactic_acid) & high_risk == 0 , laps2 + 0,
      ph_arterial >= 7.35 & ph_arterial < 7.45 & is.na(lactic_acid) & high_risk == 1 , laps2 + 12,
      ph_arterial >= 7.45 &                      is.na(lactic_acid) & high_risk == 0 , laps2 + 12,
      ph_arterial >= 7.45 &                      is.na(lactic_acid) & high_risk == 1 , laps2 + 15,

      # complete data
      ph_arterial < 7.2   &                      lactic_acid <  2                   , laps2 + 13,
      ph_arterial < 7.2   & lactic_acid >= 2   & lactic_acid <  4                   , laps2 + 19,
      ph_arterial < 7.2   &                      lactic_acid >= 4                   , laps2 + 34,
      ph_arterial >= 7.2  & ph_arterial < 7.35 & lactic_acid <  2                   , laps2 + 5,
      ph_arterial >= 7.2  & ph_arterial < 7.35 & lactic_acid >= 2 & lactic_acid < 4 , laps2 + 15,
      ph_arterial >= 7.2  & ph_arterial < 7.35 & lactic_acid >= 4                   , laps2 + 25,
      ph_arterial >= 7.35 & ph_arterial < 7.45 & lactic_acid <  2                   , laps2 + 0,
      ph_arterial >= 7.35 & ph_arterial < 7.45 & lactic_acid >= 2 & lactic_acid < 4 , laps2 + 12,
      ph_arterial >= 7.35 & ph_arterial < 7.45 & lactic_acid >= 4                   , laps2 + 26,
      ph_arterial >= 7.45 &                      lactic_acid <  2                   , laps2 + 12,
      ph_arterial >= 7.45 & lactic_acid >= 2 &   lactic_acid <  4                   , laps2 + 15,
      ph_arterial >= 7.45 &                      lactic_acid >= 4                   , laps2 + 30,
      default                                                                       = laps2
      ),
    
    # Sodium
    laps2 = fcase(
      is.na(sodium)                                                             , laps2 + 0,
      sodium <  129                                                             , laps2 + 14,
      sodium >= 129 & sodium < 135                                              , laps2 + 7,
      sodium >= 135 & sodium < 146                                              , laps2 + 0,
      sodium >= 146                                                             , laps2 + 4,
      default                                                                   = laps2
    ),
    
    # Bilirubin
    laps2 = fcase(
      is.na(bilirubin_total)                                                    , laps2 + 0,
      bilirubin_total <  2                                                      , laps2 + 0,
      bilirubin_total >= 2 & bilirubin_total < 3                                , laps2 + 11,
      bilirubin_total >= 3 & bilirubin_total < 5                                , laps2 + 18,
      bilirubin_total >= 5 & bilirubin_total < 8                                , laps2 + 25,
      bilirubin_total >= 8                                                      , laps2 + 41,
      TRUE , laps2
    ),
    
    # BUN
    laps2 = fcase(
      is.na(bun)                                                                , laps2 + 0,
      bun < 18                                                                  , laps2 + 0,
      bun >= 18 & bun < 20                                                      , laps2 + 11,
      bun >= 20 & bun < 40                                                      , laps2 + 12,
      bun >= 40 & bun < 80                                                      , laps2 + 20,
      bun >= 80                                                                 , laps2 + 25,
      default                                                                   = laps2
    ),
    
    # Creatinine
    laps2 = fcase(
      is.na(creatinine)                                                         , laps2 + 0,
      creatinine < 1                                                            , laps2 + 0,
      creatinine >= 1 & creatinine < 2                                          , laps2 + 6,
      creatinine >= 2 & creatinine < 4                                          , laps2 + 11,
      creatinine >= 4                                                           , laps2 + 5,
      default                                                                   = laps2
    ),
    
    # BUN/Cr Ratio
    laps2 = fcase(
      is.na(bun_cr_ratio)                                                       , laps2 + 0,
      bun_cr_ratio < 25                                                         , laps2 + 0,
      bun_cr_ratio >= 25                                                        , laps2 + 10,
      default                                                                   = laps2
    ),
    
    # Albumin
    laps2 = fcase(
      is.na(albumin)                                                            , laps2 + 0,
      albumin < 2                                                               , laps2 + 31,
      albumin >= 2 & albumin < 2.5                                              , laps2 + 15,
      albumin >= 2.5                                                            , laps2 + 0,
      default                                                                   = laps2
    ),
    
    # glucose_serum
    laps2 = fcase(
      is.na(glucose_serum)                                                      , laps2 + 0,
      glucose_serum < 40                                                        , laps2 + 10,
      glucose_serum >= 40 & glucose_serum < 60                                  , laps2 + 10,
      glucose_serum >= 60 & glucose_serum < 200                                 , laps2 + 0,
      glucose_serum >= 200                                                      , laps2 + 3,
      default                                                                   = laps2
    ),
    
    # Hematocrit (Hct)
    laps2 = fcase(
      is.na(hematocrit)                                                         , laps2 + 0,
      hematocrit < 20                                                           , laps2 + 7,
      hematocrit >= 20 & hematocrit < 40                                        , laps2 + 8,
      hematocrit >= 40 & hematocrit < 50                                        , laps2 + 0,
      hematocrit >= 50                                                          , laps2 + 3,
      default                                                                   = laps2
    ),
    
    # WBC
    laps2 = fcase(
      is.na(wbc) &                                               high_risk == 0 , laps2 + 0,
      is.na(wbc) &                                               high_risk == 1 , laps2 + 32,
      wbc < 5                                                                   , laps2 + 8,
      wbc >= 5 & wbc < 13                                                       , laps2 + 0,
      wbc >= 13                                                                 , laps2 + 11,
      default                                                                   = laps2
    ),
    
  # pco2_arterial
    laps2 = fcase(
      is.na(pco2_arterial)                                                      , laps2 + 0,
      pco2_arterial < 35                                                        , laps2 + 7,
      pco2_arterial >= 35 & pco2_arterial < 45                                  , laps2 + 0,
      pco2_arterial >= 45 & pco2_arterial < 55                                  , laps2 + 11,
      pco2_arterial >= 55 & pco2_arterial < 65                                  , laps2 + 13,
      pco2_arterial >= 65                                                       , laps2 + 12,
      default                                                                   = laps2
    ),
  
  # po2_arterial
    laps2 = fcase(
      is.na(po2_arterial)                                                       , laps2 + 0,
      po2_arterial < 50                                                         , laps2 + 8,
      po2_arterial >= 50 & po2_arterial < 120                                   , laps2 + 0,
      po2_arterial >= 120                                                       , laps2 + 12,
      default                                                                   = laps2
    ),
  
  # Troponin
    laps2 = fcase(
      is.na(troponin)  &                                       high_risk == 0 , laps2 + 0,
      is.na(troponin)  &                                       high_risk == 1 , laps2 + 9,
      troponin <  0.01                                                        , laps2 + 0,
      troponin >= 0.01 & troponin < 0.2                                       , laps2 + 8,
      troponin >= 0.2  & troponin < 1                                         , laps2 + 17,
      troponin >= 1    & troponin < 3                                         , laps2 + 19,
      troponin >= 3                                                           , laps2 + 25,
      default                                                                   = laps2
    ),
  
  # Temp
    laps2 = fcase(
      is.na(temp)                                                               , laps2 + 0,
      temp < 96                                                                 , laps2 + 20,
      temp >= 96    & temp < 100.5                                              , laps2 + 0,
      temp >= 100.5                                                             , laps2 + 3,
      default                                                                   = laps2
    ),

  # heart_rate
    laps2 = fcase(
      is.na(heart_rate)                                                         , laps2 + 0,
      heart_rate < 60                                                           , laps2 + 7,
      heart_rate >= 60  & heart_rate < 110                                      , laps2 + 0,
      heart_rate >= 110 & heart_rate < 140                                      , laps2 + 7,
      heart_rate >= 140                                                         , laps2 + 10,
      default                                                                   = laps2
    ),
  
  # Resp
    laps2 = fcase(
      is.na(resp)                                                               , laps2 + 0,
      resp < 20                                                                 , laps2 + 0,
      resp >= 20 & resp < 30                                                    , laps2 + 11,
      resp >= 30                                                                , laps2 + 21,
      default                                                                   = laps2
    ),
    
  # SBP
    laps2 = fcase(
      is.na(sbp)                                                                , laps2 + 0,
      sbp < 75                                                                  , laps2 + 22,
      sbp >= 75  & sbp < 90                                                     , laps2 + 13,
      sbp >= 90  & sbp < 120                                                    , laps2 + 5,
      sbp >= 120 & sbp < 140                                                    , laps2 + 0,
      sbp >= 140 & sbp < 160                                                    , laps2 + 8,
      sbp >= 160                                                                , laps2 + 14,
      default                                                                   = laps2
    ),
  
  # Shock
    laps2 = fcase(
      is.na(shock_index)                                                        , laps2 + 0,
      shock_index < 0.65                                                        , laps2 + 0,
      shock_index >= 0.65 & shock_index < 0.85                                  , laps2 + 8,
      shock_index >= 0.85                                                       , laps2 + 17,
      default                                                                   = laps2
    ),
  
  # O2Sat
    laps2 = fcase(
      is.na(spo2) &                                              high_risk == 0 , laps2 + 0,
      is.na(spo2) &                                              high_risk == 1 , laps2 + 22,
      spo2 <  90                                                                , laps2 + 22,
      spo2 >= 90  & spo2 < 94                                                   , laps2 + 12,
      spo2 >  94                                                                , laps2 + 0,
      default                                                                   = laps2
    ),
  
  # Neuro (GCS)
    laps2 = fcase(
      is.na(gcs) &                                               high_risk == 0 , laps2 + 16,
      is.na(gcs) &                                               high_risk == 1 , laps2 + 21,
      gcs == 1                                                                  , laps2 + 0,
      gcs == 2                                                                  , laps2 + 16,
      gcs == 3                                                                  , laps2 + 21,
      gcs == 4                                                                  , laps2 + 36,
      default                                                                   = laps2
    )
  )

  

```

## PF Ratio

```{r}

clif_po2_arterial <- clif_labs |> filter(lab_category == "po2_arterial") |> rename(po2_arterial = lab_value_numeric)

clif_spo2 <- clif_vitals |> filter(vital_category == "spo2") |> rename(spo2 = vital_value)

clif_fio2 <- df_hourly_resp_support |> filter(!is.na(fio2_set)) |> select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, fio2_set, location_name, location_category)


df_sf_ratio <- clif_fio2 |> 
  # left_join because we want to keep everything right now
  left_join(clif_spo2 |> 
              mutate(recorded_date = date(recorded_dttm),
                     recorded_hour = hour(recorded_dttm)) |> 
              arrange(clif_hospitalizations_joined_id, recorded_date, recorded_hour, spo2) |> 
              # taking first non-missing 
              distinct(clif_hospitalizations_joined_id, recorded_date, recorded_hour, .keep_all = TRUE),
            by = join_by(clif_hospitalizations_joined_id, recorded_date, recorded_hour)
  ) |> 
  select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, recorded_dttm, fio2_set, spo2, location_name, location_category) |> 
  mutate(sf_ratio = spo2 / (fio2_set/100)) 

df_pf_ratio <- df_sf_ratio |> 
  left_join(clif_po2_arterial |> 
              mutate(recorded_date = date(recorded_dttm),
                     recorded_hour = hour(recorded_dttm)) |> 
              # keeping lab_name in there so ELS readings will be after normal pao2 readings 
              #        ELS are sometimes falsely high
              arrange(clif_hospitalizations_joined_id, recorded_date, recorded_hour, lab_name, po2_arterial) |> 
              # taking first non-missing 
              distinct(clif_hospitalizations_joined_id, recorded_date, recorded_hour, .keep_all = TRUE),
            by = join_by(clif_hospitalizations_joined_id, recorded_date, recorded_hour)
  ) |> 
  mutate(pf_ratio = po2_arterial / (fio2_set/100)) |> 
  select(clif_hospitalizations_joined_id,
         recorded_date,
         recorded_hour,
         fio2_set,
         spo2,
         po2_arterial,
         pf_ratio,
         sf_ratio, 
         location_name, 
         location_category) 




clif_maip <- clif_respiratory_support |> filter(!is.na(mean_airway_pressure_obs)) |> select(clif_hospitalizations_joined_id, recorded_dttm, mean_airway_pressure_obs) |> 
    mutate(
    recorded_date = date(recorded_dttm),
    recorded_hour = hour(recorded_dttm)
  )

# these are maips that match and don't need to be expanded
clif_maip_matches <- clif_maip |> 
  inner_join(df_pf_ratio |> 
               distinct(clif_hospitalizations_joined_id, recorded_date, recorded_hour, pf_ratio, sf_ratio) |> 
               filter(!is.na(pf_ratio))
             ) |> 
  select(-pf_ratio, -sf_ratio)
  


# Create a time range by adding/subtracting an hour and adjust dates for invalid hours
clif_maip_expanded <- clif_maip |> 
  # only keeping the ones that DONT have matches and need a 1 hour buffer to find frience 
  anti_join(clif_maip_matches |> select(clif_hospitalizations_joined_id, recorded_date, recorded_hour)) |> 
  # Create new columns for recorded_hour - 1 and recorded_hour + 1
  mutate(
    recorded_hour_minus_1 = recorded_hour - 1,
    recorded_hour_plus_1 = recorded_hour + 1
  ) %>%
  # Reshape data to have one `recorded_hour` column with ±1 values
  pivot_longer(
    cols = c(recorded_hour, recorded_hour_minus_1, recorded_hour_plus_1),
    names_to = "time_variation",
    values_to = "recorded_hour"
  ) %>%
  # Adjust date for invalid hours (negative or > 23)
  mutate(
    # If recorded_hour is negative, adjust to 23 and subtract one day
    recorded_date = fifelse(recorded_hour < 0, recorded_date - days(1), recorded_date),
    recorded_hour = fifelse(recorded_hour < 0, 23, recorded_hour),
    
    # If recorded_hour exceeds 23, adjust to 0 and add one day
    recorded_date = fifelse(recorded_hour > 23, recorded_date + days(1), recorded_date),
    recorded_hour = fifelse(recorded_hour > 23, 0, recorded_hour)
  ) |> 
  # bring in the matches
  bind_rows(clif_maip_matches)


df_oxygenation_index <- df_pf_ratio |> 
  left_join(clif_maip_expanded, 
            by = join_by(clif_hospitalizations_joined_id, recorded_date, recorded_hour)
  ) |> 
  filter(!is.na(fio2_set), !is.na(po2_arterial), !is.na(mean_airway_pressure_obs)
         ) |> 
  arrange(clif_hospitalizations_joined_id, recorded_date, recorded_hour)  |> 
  mutate(oxygenation_index = (mean_airway_pressure_obs * fio2_set) / po2_arterial) |> 
  filter(oxygenation_index < 100 ) |> 
  select(-recorded_dttm, -time_variation) |> 
  distinct()


death_or_hospice_01 <- clif_hospitalization |>   # make dead/hospice column
  mutate(
    death_or_hospice_01 = fcase(
      discharge_category %in% 
        c("hospice", "dead", "expired", "died")       , 1,
      default                                         = 0
    )) |> 
  select(clif_hospitalizations_joined_id, mortality_enc = death_or_hospice_01)
    
  
df_oxygenation_index_analysis_prep <- df_hourly_resp_support |>
  mutate(vent_01 = fifelse(device_category %in% c("imv", "trach collar"), 1, 0)) |> 
  mutate(extubated_hour = fifelse(vent_01 == 0, 1, 0)) |> 
  mutate(recorded_dttm = ymd_h(paste(recorded_date, recorded_hour))) |> 

  # get first intubation time
  group_by(clif_hospitalizations_joined_id, vent_episode_id) |> 
  mutate(first_vent_time = ffirst(recorded_dttm, na.rm = TRUE)) |> 
  ungroup() |> 
  
  # turn non_intubation times to NA
  mutate(first_vent_time = fifelse(is.na(vent_episode_id), NA_POSIXct_, first_vent_time)) |> 
  
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(first_vent_time_enc = ffirst(first_vent_time, na.rm = TRUE)) |> 
  
  # this drops the times before first intubation so we can do survival analysis
  filter(first_vent_time_enc <= recorded_dttm) |> 
  
  # see if they ever were extubated_hour after first vent episode
  mutate(extubated_enc = fmax(extubated_hour, na.rm = TRUE)) |> 
  
  ungroup() |> 
  
  left_join(death_or_hospice_01) |> 
  
  # keep first episode of ventilation
  filter(vent_episode_id == 1, vent_01 == 1) |> 
  
  # getting last vent hour
  mutate(last_vent_time = fmax(recorded_dttm, na.rm = TRUE),
         .by = clif_hospitalizations_joined_id) |> 
  
  # creating appropriate censor variable for mortality and extubated
  mutate(extubated = fifelse(last_vent_time == recorded_dttm, extubated_enc, extubated_hour)) |> 
  mutate(mortality = fifelse(last_vent_time == recorded_dttm, mortality_enc, 0)) |> 
  
  # when ppl are extubated but die later... the extubation is what they should be censored on... not mortality
  mutate(mortality = fifelse(extubated == 1, 0, mortality)) 


OI_analysis <- df_oxygenation_index_analysis_prep |> 
  select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, time_on_ventilator = vent_episode_hour_seq, mortality, extubated) |> 
  left_join(df_oxygenation_index |> select(clif_hospitalizations_joined_id, recorded_date, recorded_hour, OI = oxygenation_index)) |> 
  # keep censoring rows or when we have OI data
  filter(!is.na(OI) | mortality == 1 | extubated == 1) |> 
  # mutate(day = floor(time_on_ventilator / 24)) |> 
  # group_by(clif_hospitalizations_joined_id, day) |> 
  # summarize(OI = max(OI),  # peak OI in each day
  #           extubated = max(extubated), 
  #           mortality = max(mortality)) |> 
  # ungroup() |> 
  # rename(time_on_ventilator = day) |> 
  group_by(clif_hospitalizations_joined_id) |> 
  mutate(peak_OI = fmax(OI, na.rm = TRUE)) |> 
  ungroup() |> 
  select(OI, mortality, time_on_ventilator, extubated, peak_OI) |> 
  filter(time_on_ventilator<600) |> 
  filter(!is.na(peak_OI))

OI_analysis_group <- OI_analysis |> 
  mutate(OI_group = cut(peak_OI, 
                        breaks = c(-Inf, 5, 10, 20, 40, 80, Inf), 
                        labels = c("<5", "5-10", "10-20", "20-40", "40-80", ">80"))) |> 
  mutate(OI_group = factor(OI_group,
                           levels = c("<5", "5-10", "10-20", "20-40", "40-80", ">80"))) |> 
  select(-peak_OI) 
  

########## EXTUBATION
# Kaplan-Meier survival analysis based on extubation
km_fit <- survfit(Surv(time_on_ventilator, extubated) ~ 1, data = OI_analysis)

# Extract the survival data
km_data <- data.frame(time = km_fit$time, surv = km_fit$surv, lower = km_fit$lower, upper = km_fit$upper)

# Plot the survival curve without the step function and with smoothed line and confidence intervals
ggplot(km_data, aes(x = time, y = surv)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "lightblue") +  # Add CI ribbon
  geom_smooth(method = "loess", span = 0.2, se = FALSE, color = "red", size = 1) +  # Add smooth survival curve
  labs(title = "Smoothed Kaplan-Meier Curve with Confidence Intervals",
       x = "Time on Ventilator (hours)", 
       y = "Survival Probability") +
  theme_minimal()


# Kaplan-Meier survival analysis stratified by OI group
km_fit_ext_group <- survfit(Surv(time_on_ventilator, extubated) ~ OI_group, data = OI_analysis_group)

# Extract the survival data from the Kaplan-Meier object
km_data_ext <- data.frame(
  time = km_fit_ext_group$time,
  surv = km_fit_ext_group$surv,
  lower = km_fit_ext_group$lower, 
  upper = km_fit_ext_group$upper,
  strata = rep(names(km_fit_ext_group$strata), km_fit_ext_group$strata)  # Correctly map strata names
)
# Assuming 'strata' in km_data_ext is a factor or character
km_data_ext$strata <- factor(km_data_ext$strata, levels = c("OI_group=<5", "OI_group=5-10", "OI_group=10-20", "OI_group=20-40", "OI_group=40-80", "OI_group=>80"))


# Plot the survival curve with a smooth line for each OI group using GAM smoothing
ggplot(km_data_ext, aes(x = time, y = surv, color = strata, fill = strata)) +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"), se = FALSE, size = 1.5) +  # Smooth with GAM
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +  # Add CI ribbon, auto-fills by group
  
  labs(title = "Survival to Extubation Stratified by Peak OI",
       x = "Time on Ventilator (hours)",
       y = "Probability of Survival to Extubation") +
  theme_minimal() +
  theme(legend.position = "right",
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12)) +
  scale_color_brewer(palette = "Set1") +  # Set color palette for groups
  scale_fill_brewer(palette = "Set1")  # Match fill with color for ribbon



############### MORTALITY
# Plot hazard function for death without extubation
death_fit <- survfit(Surv(time_on_ventilator, mortality) ~ 1, data = OI_analysis)

# Extract the survival data
km_data_death <- data.frame(time = death_fit$time, surv = death_fit$surv, lower = death_fit$lower, upper = death_fit$upper)

ggsurvplot(km_data_death, aes(x = time, y = surv)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "lightblue") +  # Add CI ribbon
  geom_smooth(method = "loess", span = 0.2, se = FALSE, color = "red", size = 1) +  # Add smooth survival curve
  labs(title = "Smoothed Kaplan-Meier Curve with Confidence Intervals",
       x = "Time on Ventilator (hours)", 
       y = "Survival Probability") +
    theme_minimal()


# Kaplan-Meier survival analysis stratified by OI group
km_fit_mort_group <- survfit(Surv(time_on_ventilator, mortality) ~ OI_group, data = OI_analysis_group)

# Extract the survival data from the Kaplan-Meier object
km_data_mort <- data.frame(
  time = km_fit_mort_group$time,
  surv = km_fit_mort_group$surv,
  lower = km_fit_mort_group$lower, 
  upper = km_fit_mort_group$upper,
  strata = rep(names(km_fit_mort_group$strata), km_fit_mort_group$strata)  # Correctly map strata names
)
# Assuming 'strata' in km_data_mort is a factor or character
km_data_mort$strata <- factor(km_data_mort$strata, levels = c("OI_group=<5", "OI_group=5-10", "OI_group=10-20", "OI_group=20-40", "OI_group=40-80", "OI_group=>80"))


# Plot the survival curve with a smooth line for each OI group using GAM smoothing
ggplot(km_data_mort, aes(x = time, y = surv, color = strata, fill = strata)) +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs"), se = FALSE, size = 1.5) +  # Smooth with GAM
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +  # Add CI ribbon, auto-fills by group
  
  labs(title = "Survival to Extubation Stratified by Peak OI",
       x = "Time on Ventilator (hours)",
       y = "Probability of Survival to Extubation") +
  theme_minimal() +
  theme(legend.position = "right",
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12)) +
  scale_color_brewer(palette = "Set1") +  # Set color palette for groups
  scale_fill_brewer(palette = "Set1")  # Match fill with color for ribbon






# Combine both survival and death into one plot OI_analysis
competing_risks <- survfit(Surv(time_on_ventilator, extubated + mortality) ~ 1, data = OI_analysis)

ggsurvplot(competing_risks, data = OI_analysis,
           title = "Competing Risk: Survival vs. Death",
           xlab = "Time on Ventilator (days)",
           ylab = "Cumulative Event Probability",
           conf.int = TRUE)



# Stratified survival curves by OI
OI_analysis_test  <- OI_analysis |> 
  mutate(median_OI = median(OI, na.rm = TRUE)) |> 
  mutate(
    OI_group = ifelse(OI >median_OI, "High OI", "Low OI")
         )

# Kaplan-Meier survival analysis stratified by OI
km_oi_fit <- survfit(Surv(time_on_ventilator, extubated) ~ OI_group, data = OI_analysis_test)

# Plot the stratified survival curves
ggsurvplot(km_oi_fit, data = OI_analysis_test,
           title = "Survival to Extubation Stratified by Oxygenation Index",
           xlab = "Time on Ventilator (days)",
           ylab = "Probability of Survival to Extubation",
           conf.int = TRUE)
           


```


# Analysis

## analysis 1
propensity score match M/F on LAPS2, age, pf ratio
- need to decide when we prop match
- ? first 24 hrs of ventilation.  

regress gender on Vt/IBW... what does female gender do for getting LTVV
add ht to regression
? prop match after this

use a for loop to see how this changes over time, run the regression on each MV day


## Table 3 Predictors of Mode Variation / Trach Variation / LTVV Variation / Prone Variation



## Oxygenation Index

```{r}



```



