---
title: "01_ventilation_variation_script"
author: Nick Ingraham
date: today
execute: 
  echo: false
format: 
  html:
    embed-resources: true
    number-sections: true
    toc: true
    html-q-tags: true
    code-fold: true
editor: source
editor_options: 
  chunk_output_type: console
---

## CLIF Setup

### Libraries

```{r}
#| label: installing packages
#| timeit: true

packages <- c("tidyverse","ggthemes","styler","readxl","writexl","DBI","dbplyr","knitr","pandoc","janitor", "data.table", "duckdb","powerjoin","collapse","tidyfast","datapasta","fst","dtplyr","bit64","zoo","fuzzyjoin","arrow","hrbrthemes","here","table1", "rvest", "tidymodels", "pscl", "survival", "survminer", "KMsurv")

install_if_missing <- function(package) {
  if (!require(package, character.only = TRUE)) {
    install.packages(package, dependencies = TRUE)
    library(package, character.only = TRUE)
  }
}

sapply(packages, install_if_missing)

```


### Utils

```{r}
# Load the configuration utility
source("utils/config.R")



```


### Functions

```{r}
#| label: Functions
#| timeit: true


# Quickly look at the data like we would in stata, default is 100
ni_peek <- function(x, n=100){
  view(head(x, n))
}

# check missing variables
ni_count_missing <- function(df, group_vars, x_var) {
  df |> 
    group_by(pick({{ group_vars }})) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
    )
}
# flights |>  count_missing(c(year, month, day), dep_time)

# look at the variables
ni_check_variables <- function(df, n=500) {
  check <- tibble(
    col_name = names(df), 
    col_type = map_chr(df, vctrs::vec_ptype_full),
    n_miss = map_int(df, \(x) sum(is.na(x)))
  )
  print(check, n=n)
}

ni_count_prop <- function(df, var, sort = TRUE) {
  df |>
    count({{ var }}, sort = sort) |>
    mutate(prop = n / sum(n)
    )
}

# Identify and create a table of duplicate rows based on hospitalization_id
ni_duplicate_finder <- function(df, group_vars = c(hospitalization_id), n=1){
df |> 
  dplyr::group_by(pick({{ group_vars }})) |> 
  filter(n() > {{ n }}) |> 
  ungroup()
}

ni_tic <- function() {
  .GlobalEnv$time_start_temp <- proc.time()
  .GlobalEnv$time_start_sys <- Sys.time()
  return(Sys.time())
}

ni_toc <- function() {
  time_end_sys <- Sys.time()
  .GlobalEnv$time_diff.time <- round(time_end_sys - time_start_sys,2)
  mylist <- list(time_diff.time, cat("Finished in",timetaken(time_start_temp),"\n"
             ))
return(print(mylist[[1]]))
}

fio2warning <- function() {
  warning("fio2 variable needed to be fixed, it was multiplied by 100!!!")
}

labwarning <- function() {
  warning("lab values are character and needed to be fixed, they were forced to numeric!!!")
}

vitalwarning <- function() {
  warning("vital values are character and needed to be fixed, they were forced to numeric!!!")
}



read_data <- function(file_path) {
  file_path_temp <- paste0(path_cliffed_files,"/", file_path, ".", file_type)
  print(file_path_temp)
  
  if (grepl("\\.csv$", file_path_temp)) {
    return(read.csv(file_path_temp) 
    )
    
  } else if (grepl("\\.parquet$", file_path_temp)) {
    return(arrow::open_dataset(file_path_temp)  |> 
             collect()
    )
    
  } else if (grepl("\\.fst$", file_path_temp)) {
    return(fst::read.fst(file_path_temp) 
    )
  } else {
    stop("Unsupported file format")
  }
}


```

# Import

### Cohort identification

```{r}
#~~~~~~~~~~
# ID cohort
#~~~~~~~~~~

# Main Respiratory Support Table
#~~ using readr or fst or arrow (parquet) package depending on the file type. (THESE WERE SET DURING SET UP ^^ )
clif_respiratory_support_start <- read_data("clif_respiratory_support") |> select(hospitalization_id, device_category, tracheostomy) 
clif_hospitalization_start <- read_data("clif_hospitalization") |> select(hospitalization_id, admission_dttm, age_at_admission, patient_id)


# getting a keep_list of hospitalization_ids that have vent or trach during their encounter... we will use this right_join the dfs below
df_cohort_keep <- clif_respiratory_support_start |> 
  
  # Just getting those ventilated or trach
  filter(str_to_lower(device_category) == "imv" | tracheostomy == 1) |> 
  
  # getting age at admission
  left_join(clif_hospitalization_start) |> 
  
  # Exclusion based on date
  left_join(clif_hospitalization_start) |>
  filter(
    lubridate::year(admission_dttm) >= 2020 | hospitalization_id == 1767475 | hospitalization_id == 2044432,
    lubridate::year(admission_dttm) <= 2021,
    age_at_admission >= 18,
    !is.na(age_at_admission)
    ) |>  
  select(hospitalization_id, patient_id) |> 
  distinct()

# List all objects in the global environment
all_objects <- ls()

# Identify objects ending with "_start"
df_start_objects <- grep("_start$", all_objects, value = TRUE)

# Remove identified objects
rm(list = df_start_objects)
gc()

```

### Importing function

```{r}
#~~~~~~~~~~
# Importing function
#~~~~~~~~~~

# Function for importing files easily just with the file of the clif_table
import_df <- function(x) {
  # Construct the file path
  file_path <- paste0(path_cliffed_files,"/", x, ".", file_type)
  
  # Dynamically call the appropriate read function based on file_type
  
  if (file_type == "parquet") {
    
  read_function <- get(paste0("open_dataset")) 
  
  df <- read_function(file_path) |>
    
    # helps with glitch in open_dataset
    mutate(across(where(is.character), as.character)) |> 
    
    # right join early so files are smaller
    right_join(df_cohort_keep) |> 
    
    # unfactor things to ensure everything is lowercase
    mutate(across(where(is.factor), as.character)) |> 
    
    # get everything to lower
    mutate(across(where(is_character), str_to_lower)) |> 
    
    # only need if using open dataset
    collect()
  
  } else {
    
    read_function <- get(paste0("read_", file_type)) 
    
    df <- read_function(file_path) |>
      
      # right join early so files are smaller
      right_join(df_cohort_keep) |> 
      
      # unfactor things to ensure everything is lowercase
      mutate(across(where(is.factor), as.character)) |> 
      
      # get everything to lower
      mutate(across(where(is_character), str_to_lower)) 
      
  }
  
  
  # Find all datetime variables containing 'dttm'
  datetime_vars <- names(df)[grepl("dttm", names(df))]
  
  # Check and convert datetime variables
  for (var in datetime_vars) {
    if (!inherits(df[[var]], "POSIXct")) {
      
      # Attempt to parse datetime using a common format, adjust based on your actual format
      df[[var]] <- ymd_hms(df[[var]], quiet = TRUE)
      
      # Check if it just turned things into NA
      if (is.na(ffirst(df[[var]], na.rm = TRUE))) {
        stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
        
        
        # Check if conversion failed (if it's still not POSIXct)
        if (!inherits(df[[var]], "POSIXct")) {
          stop(paste("Conversion failed for:", var,"\n","\nPlease look at your clif data for   ", var, "\nmake sure its POSIXct format!!"))
          
        }
        
      }
    }
    print(paste("Woohoo",var,"is in the correct dttm format!!"))
  }
  
  # Join with cohort data and glimpse the result
  df <- df %>% 
    right_join(df_cohort_keep) %>% 
    glimpse()
  
  # Assign the dataframe to a new variable in the global environment named after the file_name
  assign(x, df, envir = .GlobalEnv)
}


```



